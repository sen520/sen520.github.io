<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>silence聆听°</title>
  
  <subtitle>个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.silencew.cn/"/>
  <updated>2020-06-17T13:05:46.404Z</updated>
  <id>https://blog.silencew.cn/</id>
  
  <author>
    <name>silence 聆听°</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>excel相关操作</title>
    <link href="https://blog.silencew.cn/2020/06/17/python/03.%E8%AF%BB%E5%8F%96excel/"/>
    <id>https://blog.silencew.cn/2020/06/17/python/03.读取excel/</id>
    <published>2020-06-16T16:00:00.000Z</published>
    <updated>2020-06-17T13:05:46.404Z</updated>
    
    <content type="html"><![CDATA[<p>关于excel，大部分操作应该主要用于数据分析，其中，最主流的方式应该是采用pandas库，这里主要介绍几种方式来读写excel</p><h4 id="读取excel数据"><a href="#读取excel数据" class="headerlink" title="读取excel数据"></a>读取excel数据</h4><p>处理一般的excel，尤其没有合并单元格之类的情况时，我们可以采用普通的方法</p><a id="more"></a><p>这里采用xlrd库</p><ul><li><p>无单元格合并的情况下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_list</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    parse a list</span></span><br><span class="line"><span class="string">    :param data: list</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    data_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(data)):</span><br><span class="line">        data_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> index, key <span class="keyword">in</span> enumerate(data[<span class="number">0</span>]):</span><br><span class="line">            data_dict[key] = data[i][index]</span><br><span class="line">        data_list.append(data_dict)</span><br><span class="line">    <span class="keyword">return</span> data_list</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_excel</span><span class="params">(filename, sheet=None)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    read excel and parse every line</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param name: file of absolute path</span></span><br><span class="line"><span class="string">    :return: some dict which is about everyline of list</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    workbook = xlrd.open_workbook(filename)</span><br><span class="line">    total_data = []</span><br><span class="line">    <span class="keyword">if</span> sheet:</span><br><span class="line">        sh = workbook.sheet_by_name(sheet)</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(<span class="number">0</span>, sh.nrows):</span><br><span class="line">            row_list = sh.row_values(row)</span><br><span class="line">            total_data.append(row_list)</span><br><span class="line">    <span class="keyword">return</span> parse_list(total_data)</span><br></pre></td></tr></table></figure><p>上述方法主要针对特定的sheet，当然，根据上述方法也也可进行改变，读取所有的sheet</p><p>关键方法在于read_excel，所以我们来改写该方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_excel</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    read excel and parse every line</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param name: file of absolute path</span></span><br><span class="line"><span class="string">    :return: some dict which is about everyline of list</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    workbook = xlrd.open_workbook(filename)</span><br><span class="line">    total_data = []</span><br><span class="line">    name_sheets = workbook.sheet_names()</span><br><span class="line">    <span class="keyword">for</span> sheet <span class="keyword">in</span> name_sheets:</span><br><span class="line">        sh = workbook.sheet_by_name(sheet)</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(<span class="number">0</span>, sh.nrows):</span><br><span class="line">            row_list = sh.row_values(row)</span><br><span class="line">            total_data.append(row_list)</span><br><span class="line">    <span class="keyword">return</span> parse_list(total_data)</span><br></pre></td></tr></table></figure></li><li><p>主要用于处理合并存在合并单元格的情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_excel</span><span class="params">()</span>:</span></span><br><span class="line">    data_list = []</span><br><span class="line">    <span class="keyword">with</span> xlrd.open_workbook(<span class="string">r'D:\0325.xlsx'</span>) <span class="keyword">as</span> workbook:</span><br><span class="line">        name_sheets = workbook.sheet_names()  <span class="comment"># 获取Excel的sheet表列表，存储是sheet表名</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> name_sheets:  <span class="comment"># for 循环读取每一个sheet表的内容</span></span><br><span class="line">            apply_dic = []</span><br><span class="line">            sheet_info = workbook.sheet_by_name(index)  <span class="comment"># 根据表名获取表中的所有内容，sheet_info也是列表，列表中的值是每个单元格里值</span></span><br><span class="line">            first_line = sheet_info.row_values(<span class="number">0</span>)  <span class="comment"># 获取首行，我这里的首行是表头，我打算用表头作为字典的key，每一行数据对应表头的value，每一行组成一个字典</span></span><br><span class="line">            values_merge_cell = merge_cell(sheet_info)  <span class="comment"># 这里是调用处理合并单元格的函数</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, sheet_info.nrows):  <span class="comment"># 开始为组成字典准备数据</span></span><br><span class="line">                other_line = sheet_info.row_values(i)</span><br><span class="line">                <span class="keyword">for</span> key <span class="keyword">in</span> values_merge_cell.keys():</span><br><span class="line">                    <span class="keyword">if</span> key[<span class="number">0</span>] == i:</span><br><span class="line">                        other_line[key[<span class="number">1</span>]] = values_merge_cell[key]</span><br><span class="line">                <span class="comment"># print(other_line)</span></span><br><span class="line">                dic = list_dic(first_line, other_line)  <span class="comment"># 调用组合字典的函数，传入key和value，字典生成</span></span><br><span class="line">                apply_dic.append(dic)</span><br><span class="line">            data_list.append(&#123;<span class="string">'index'</span>: index, <span class="string">'data'</span>: apply_dic&#125;)</span><br><span class="line">    <span class="keyword">return</span> data_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_dic</span><span class="params">(list1, list2)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    two lists merge a dict,a list as key,other list as value</span></span><br><span class="line"><span class="string">    :param list1:key</span></span><br><span class="line"><span class="string">    :param list2:value</span></span><br><span class="line"><span class="string">    :return:dict</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    dic = dict(map(<span class="keyword">lambda</span> x, y: [x, y], list1, list2))</span><br><span class="line">    <span class="keyword">return</span> dic</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_cell</span><span class="params">(sheet_info)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    #handle Merge transverse cells and handle Merge Vertical Cells, assign empty cells,</span></span><br><span class="line"><span class="string">    :param rlow:row, include row exclusive of row_range</span></span><br><span class="line"><span class="string">    :param rhigh:row_range</span></span><br><span class="line"><span class="string">    :param clow:col, include col exclusive of col_range</span></span><br><span class="line"><span class="string">    :param chigh:col_range</span></span><br><span class="line"><span class="string">    :param sheet_info:object of sheet</span></span><br><span class="line"><span class="string">    :return:dic contain all of empty cells value</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    merge = &#123;&#125;</span><br><span class="line">    merge_cells = sheet_info.merged_cells</span><br><span class="line">    <span class="keyword">for</span> (rlow, rhigh, clow, chigh) <span class="keyword">in</span> merge_cells:</span><br><span class="line">        value_mg_cell = sheet_info.cell_value(rlow, clow)</span><br><span class="line">        <span class="keyword">if</span> rhigh - rlow == <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># Merge transverse cells</span></span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> range(chigh - clow - <span class="number">1</span>):</span><br><span class="line">                merge[(rlow, clow + n + <span class="number">1</span>)] = value_mg_cell</span><br><span class="line">        <span class="keyword">elif</span> chigh - clow == <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># Merge Vertical Cells</span></span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> range(rhigh - rlow - <span class="number">1</span>):</span><br><span class="line">                merge[(rlow + n + <span class="number">1</span>, clow)] = value_mg_cell</span><br><span class="line">    <span class="keyword">return</span> merge</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    get_excel()</span><br></pre></td></tr></table></figure></li></ul><h4 id="写excel"><a href="#写excel" class="headerlink" title="写excel"></a>写excel</h4><ul><li><p>生成xlsx，使用pandas</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_excel</span><span class="params">(data, filename, keys=<span class="string">''</span>)</span>:</span></span><br><span class="line">    data_df = pd.DataFrame(data)</span><br><span class="line">    <span class="keyword">if</span> keys != <span class="string">''</span>:</span><br><span class="line">        data_df.columns = list(keys)</span><br><span class="line">    writer = pd.ExcelWriter(<span class="string">'&#123;&#125;.xlsx'</span>.format(filename))</span><br><span class="line">    data_df.to_excel(writer, index=<span class="literal">None</span>)</span><br><span class="line">    writer.save()</span><br></pre></td></tr></table></figure></li><li><p>生成csv</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_csv</span><span class="params">(name, data_list)</span>:</span></span><br><span class="line">    fieldnames = data_list[<span class="number">0</span>]</span><br><span class="line">    print(fieldnames)</span><br><span class="line">    <span class="keyword">with</span> open(name + <span class="string">'.csv'</span>, mode=<span class="string">'w'</span>, newline=<span class="string">''</span>, encoding=<span class="string">'utf-8-sig'</span>) <span class="keyword">as</span> csv_file:</span><br><span class="line">        writer = csv.DictWriter(csv_file, fieldnames=fieldnames)</span><br><span class="line">        writer.writeheader()</span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> data_list:</span><br><span class="line">            writer.writerow(data)</span><br></pre></td></tr></table></figure><p>当然，可以通过json去生成csv</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">json_to_csv</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(name) <span class="keyword">as</span> f:</span><br><span class="line">        a = json.loads(f.read())</span><br><span class="line">        write_csv(name, a)</span><br></pre></td></tr></table></figure><p>这里依旧可以使用pandas</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_to_csv</span><span class="params">(data_list, csv_key, name)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    save data to csv</span></span><br><span class="line"><span class="string">    :param data_list: data</span></span><br><span class="line"><span class="string">    :param csv_key: csv column</span></span><br><span class="line"><span class="string">    :param name: file name</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    final_data = []</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> data_list:</span><br><span class="line">        sign_key = []</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> data.items():</span><br><span class="line">            sign_key.append(value)</span><br><span class="line">        final_data.append(sign_key)</span><br><span class="line">    <span class="comment"># 将总数据转化为data frame再输出</span></span><br><span class="line">    df = pd.DataFrame(data=final_data,</span><br><span class="line">                      columns=csv_key)</span><br><span class="line">    df.to_csv(name + <span class="string">'.csv'</span>, index=<span class="literal">False</span>, encoding=<span class="string">'utf-8_sig'</span>)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于excel，大部分操作应该主要用于数据分析，其中，最主流的方式应该是采用pandas库，这里主要介绍几种方式来读写excel&lt;/p&gt;
&lt;h4 id=&quot;读取excel数据&quot;&gt;&lt;a href=&quot;#读取excel数据&quot; class=&quot;headerlink&quot; title=&quot;读取excel数据&quot;&gt;&lt;/a&gt;读取excel数据&lt;/h4&gt;&lt;p&gt;处理一般的excel，尤其没有合并单元格之类的情况时，我们可以采用普通的方法&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://blog.silencew.cn/categories/python/"/>
    
    
      <category term="python" scheme="https://blog.silencew.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python定时器</title>
    <link href="https://blog.silencew.cn/2020/06/10/python/04.%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    <id>https://blog.silencew.cn/2020/06/10/python/04.定时器/</id>
    <published>2020-06-09T16:00:00.000Z</published>
    <updated>2020-06-19T12:12:12.710Z</updated>
    
    <content type="html"><![CDATA[<p>其实定时器的原理就是一个多线程的东西，一个负责时间的管理，另一个负责添加、设置任务</p><p>现在网络上有很多定时器设置的方法，这里主要提取一个比较好用的。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskTimer</span>:</span></span><br><span class="line">    __instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        单例模式</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cls.__instance:</span><br><span class="line">            cls.__instance = object.__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls.__instance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">'task_queue'</span>):</span><br><span class="line">            setattr(self, <span class="string">'task_queue'</span>, [])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">'is_running'</span>):</span><br><span class="line">            setattr(self, <span class="string">'is_running'</span>, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write_log</span><span class="params">(self, level, msg)</span>:</span></span><br><span class="line">        cur_time = datetime.datetime.now()</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'./task.log'</span>, mode=<span class="string">'a+'</span>, encoding=<span class="string">'utf8'</span>) <span class="keyword">as</span> file:</span><br><span class="line">            s = <span class="string">"["</span> + str(cur_time) + <span class="string">"]["</span> + level + <span class="string">"]   "</span> + msg</span><br><span class="line">            print(s)</span><br><span class="line">            file.write(s + <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        处理任务队列</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">for</span> task <span class="keyword">in</span> self.task_queue:</span><br><span class="line">                <span class="keyword">if</span> task[<span class="string">'interval'</span>]:</span><br><span class="line">                    self.cycle_task(task)</span><br><span class="line">                <span class="keyword">elif</span> task[<span class="string">'timing'</span>]:</span><br><span class="line">                    self.timing_task(task)</span><br><span class="line">            sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cycle_task</span><span class="params">(self, task)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        周期任务</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> task[<span class="string">'next_sec'</span>] &lt;= int(time.time()):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                task[<span class="string">'fun'</span>](*task[<span class="string">'arg'</span>])</span><br><span class="line">                self.write_log(<span class="string">"正常"</span>, <span class="string">"周期任务："</span> + task[<span class="string">'fun'</span>].__name__ + <span class="string">" 已执行"</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                self.write_log(<span class="string">"异常"</span>, <span class="string">"周期任务："</span> + task[<span class="string">'fun'</span>].__name__ + <span class="string">" 函数内部异常："</span> + str(e))</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                task[<span class="string">'next_sec'</span>] = int(time.time()) + task[<span class="string">'interval'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">timing_task</span><span class="params">(self, task)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        定时任务</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 今天已过秒数</span></span><br><span class="line">        today_sec = self.get_today_until_now()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 到了第二天，就重置任务状态</span></span><br><span class="line">        <span class="keyword">if</span> task[<span class="string">'today'</span>] != self.get_today():</span><br><span class="line">            task[<span class="string">'today'</span>] = self.get_today()</span><br><span class="line">            task[<span class="string">'today_done'</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第一次执行</span></span><br><span class="line">        <span class="keyword">if</span> task[<span class="string">'first_work'</span>]:</span><br><span class="line">            <span class="keyword">if</span> today_sec &gt;= task[<span class="string">'task_sec'</span>]:</span><br><span class="line">                task[<span class="string">'today_done'</span>] = <span class="literal">True</span></span><br><span class="line">                task[<span class="string">'first_work'</span>] = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                task[<span class="string">'first_work'</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 今天还没有执行</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> task[<span class="string">'today_done'</span>]:</span><br><span class="line">            <span class="keyword">if</span> today_sec &gt;= task[<span class="string">'task_sec'</span>]:  <span class="comment"># 到点了，开始执行任务</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    task[<span class="string">'fun'</span>](*task[<span class="string">'arg'</span>])</span><br><span class="line">                    self.write_log(<span class="string">"正常"</span>, <span class="string">"定时任务："</span> + task[<span class="string">'fun'</span>].__name__ + <span class="string">" 已执行"</span>)</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    self.write_log(<span class="string">"异常"</span>, <span class="string">"定时任务："</span> + task[<span class="string">'fun'</span>].__name__ + <span class="string">" 函数内部异常："</span> + str(e))</span><br><span class="line">                <span class="keyword">finally</span>:</span><br><span class="line">                    task[<span class="string">'today_done'</span>] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">if</span> task[<span class="string">'first_work'</span>]:</span><br><span class="line">                        task[<span class="string">'first_work'</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_today_until_now</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取今天凌晨到现在的秒数</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i = datetime.datetime.now()</span><br><span class="line">        <span class="keyword">return</span> i.hour * <span class="number">3600</span> + i.minute * <span class="number">60</span> + i.second</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_today</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取今天的日期</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i = datetime.datetime.now()</span><br><span class="line">        <span class="keyword">return</span> i.day</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">join_task</span><span class="params">(self, fun, arg, interval=None, timing=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        interval和timing只能存在1个</span></span><br><span class="line"><span class="string">        :param fun: 你要调用的任务</span></span><br><span class="line"><span class="string">        :param arg: fun的参数</span></span><br><span class="line"><span class="string">        :param interval: 周期任务，单位秒</span></span><br><span class="line"><span class="string">        :param timing: 定时任务，取值：[0,24)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 参数校验</span></span><br><span class="line">        <span class="keyword">if</span> (interval != <span class="literal">None</span> <span class="keyword">and</span> timing != <span class="literal">None</span>) <span class="keyword">or</span> (interval == <span class="literal">None</span> <span class="keyword">and</span> timing == <span class="literal">None</span>):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'interval和timing只能选填1个'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> timing <span class="keyword">and</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= timing &lt; <span class="number">24</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'timing的取值范围为[0,24)'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> interval <span class="keyword">and</span> interval &lt; <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'interval最少为5'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 封装一个task</span></span><br><span class="line">        task = &#123;</span><br><span class="line">            <span class="string">'fun'</span>: fun,</span><br><span class="line">            <span class="string">'arg'</span>: arg,</span><br><span class="line">            <span class="string">'interval'</span>: interval,</span><br><span class="line">            <span class="string">'timing'</span>: timing,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 封装周期或定时任务相应的参数</span></span><br><span class="line">        <span class="keyword">if</span> timing:</span><br><span class="line">            task[<span class="string">'task_sec'</span>] = timing * <span class="number">3600</span></span><br><span class="line">            task[<span class="string">'today_done'</span>] = <span class="literal">False</span></span><br><span class="line">            task[<span class="string">'first_work'</span>] = <span class="literal">True</span></span><br><span class="line">            task[<span class="string">'today'</span>] = self.get_today()</span><br><span class="line">        <span class="keyword">elif</span> interval:</span><br><span class="line">            task[<span class="string">'next_sec'</span>] = int(time.time()) + interval</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 把task加入任务队列</span></span><br><span class="line">        self.task_queue.append(task)</span><br><span class="line"></span><br><span class="line">        self.write_log(<span class="string">"正常"</span>, <span class="string">"新增任务："</span> + fun.__name__)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        开始执行任务</span></span><br><span class="line"><span class="string">        返回线程标识符</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_running:</span><br><span class="line">            thread = Thread(target=self.work)</span><br><span class="line"></span><br><span class="line">            thread.start()</span><br><span class="line"></span><br><span class="line">            self.is_running = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            self.write_log(<span class="string">"正常"</span>, <span class="string">"TaskTimer已开始运行！"</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> thread.ident</span><br><span class="line"></span><br><span class="line">        self.write_log(<span class="string">"警告"</span>, <span class="string">"TaskTimer已运行，请勿重复启动！"</span>)</span><br></pre></td></tr></table></figure><p>调用如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(arg1, arg2)</span>:</span></span><br><span class="line">    print(<span class="string">'f1'</span>, arg1, arg2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(arg1)</span>:</span></span><br><span class="line">    print(<span class="string">'f2'</span>, arg1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'f3'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f4</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'周期任务'</span>, int(time.time()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">timer = TaskTimer()</span><br><span class="line">timer.join_task(f4, [], interval=<span class="number">10</span>)  <span class="comment"># 每10秒执行1次</span></span><br><span class="line"><span class="comment"># 开始执行（此时才会创建线程）</span></span><br><span class="line">timer.start()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实定时器的原理就是一个多线程的东西，一个负责时间的管理，另一个负责添加、设置任务&lt;/p&gt;
&lt;p&gt;现在网络上有很多定时器设置的方法，这里主要提取一个比较好用的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://blog.silencew.cn/categories/python/"/>
    
    
      <category term="python" scheme="https://blog.silencew.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>yeild</title>
    <link href="https://blog.silencew.cn/2020/03/26/python/spider/01.yield/"/>
    <id>https://blog.silencew.cn/2020/03/26/python/spider/01.yield/</id>
    <published>2020-03-25T16:00:00.000Z</published>
    <updated>2020-05-18T12:01:30.531Z</updated>
    
    <content type="html"><![CDATA[<p>yeild之前在scrapy有所接触，但并没有深挖其意义。今天在读一篇文章的时候，发现其在scrapy外使用了yeild，所以就简单查了一下</p><h4 id="yeild"><a href="#yeild" class="headerlink" title="yeild"></a>yeild</h4><p>可以先把<code>yeild</code>当做<code>return</code>来使用，但是返回值是一个<code>generator</code>，可以根据下面的代码来理解</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"starting..."</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res = <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">        print(<span class="string">"res:"</span>,res)</span><br><span class="line">g = foo()</span><br><span class="line">print(next(g))</span><br><span class="line">print(<span class="string">"*"</span>*<span class="number">20</span>)</span><br><span class="line">print(next(g))</span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">starting...</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">********************</span></span><br><span class="line"><span class="string">res: None</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p><strong>理解</strong></p><ul><li><p>程序开始执行，因为foo函数中含有yield关键字，所以foo函数并不会真的执行，而是先得到一个生成器（相当于一个对象）</p></li><li><p>直到调用next方法，foo函数才开始执行，先执行foo中的print，然后进入循环</p></li><li>遇到了yield后，先return了一个4,之后程序停止</li><li>下面再次执行next(g)，这个时候是从刚才next程序停止的 地方开始执行的所以res是None</li><li>然后同上</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(num)</span>:</span></span><br><span class="line">    print(<span class="string">"starting..."</span>)</span><br><span class="line">    <span class="keyword">while</span> num&lt;<span class="number">10</span>:</span><br><span class="line">        num=num+<span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> num</span><br><span class="line">print(foo(<span class="number">1</span>))</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> foo(<span class="number">0</span>):</span><br><span class="line">    print(n)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">&lt;generator object foo at 0x0000020899ACCBA0&gt;</span></span><br><span class="line"><span class="string">starting...</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">5</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string">7</span></span><br><span class="line"><span class="string">8</span></span><br><span class="line"><span class="string">9</span></span><br><span class="line"><span class="string">10</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h4 id="简单爬虫小例子"><a href="#简单爬虫小例子" class="headerlink" title="简单爬虫小例子"></a>简单爬虫小例子</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO, format=<span class="string">'%(asctime)s - %(levelname)s:%(message)s'</span>)</span><br><span class="line"></span><br><span class="line">TOTAL_PAGE = <span class="number">10</span></span><br><span class="line">BASE_URL = <span class="string">'https://static1.scrape.cuiqingcai.com'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_index</span><span class="params">(html)</span>:</span></span><br><span class="line">    doc = pq(html)</span><br><span class="line">    links = doc(<span class="string">'.el-card .name'</span>)</span><br><span class="line">    <span class="keyword">for</span> link <span class="keyword">in</span> links.items():</span><br><span class="line">        href = link.attr(<span class="string">'href'</span>)</span><br><span class="line">        detail_url = urljoin(BASE_URL, href)</span><br><span class="line">        logging.info(<span class="string">'get detail url %s'</span>, detail_url)</span><br><span class="line">        <span class="keyword">yield</span> detail_url</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scrape_index</span><span class="params">(page)</span>:</span></span><br><span class="line">    index_url = <span class="string">f'<span class="subst">&#123;BASE_URL&#125;</span>/page/<span class="subst">&#123;page&#125;</span>'</span></span><br><span class="line">    <span class="keyword">return</span> scrape_page(index_url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scrape_page</span><span class="params">(url)</span>:</span></span><br><span class="line">    logging.info(<span class="string">'scraping %s...'</span>, url)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.text</span><br><span class="line">        logging.error(<span class="string">'get invalid status code %s while scraping %s'</span>, response.status_code)</span><br><span class="line">    <span class="keyword">except</span> requests.RequestException:</span><br><span class="line">        logging.error(<span class="string">'error occurred while scraping %s'</span>, url, exc_info=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> range(<span class="number">1</span>, TOTAL_PAGE + <span class="number">1</span>):</span><br><span class="line">        index_html = scrape_index(page)</span><br><span class="line">        detail_urls = parse_index(index_html)</span><br><span class="line">        logging.info(<span class="string">'detail urls %s'</span>, list(detail_urls))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;yeild之前在scrapy有所接触，但并没有深挖其意义。今天在读一篇文章的时候，发现其在scrapy外使用了yeild，所以就简单查了一下&lt;/p&gt;
&lt;h4 id=&quot;yeild&quot;&gt;&lt;a href=&quot;#yeild&quot; class=&quot;headerlink&quot; title=&quot;yeild&quot;&gt;&lt;/a&gt;yeild&lt;/h4&gt;&lt;p&gt;可以先把&lt;code&gt;yeild&lt;/code&gt;当做&lt;code&gt;return&lt;/code&gt;来使用，但是返回值是一个&lt;code&gt;generator&lt;/code&gt;，可以根据下面的代码来理解&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://blog.silencew.cn/categories/python/"/>
    
      <category term="spider" scheme="https://blog.silencew.cn/categories/python/spider/"/>
    
    
      <category term="python" scheme="https://blog.silencew.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>windows关闭系统线程，进程</title>
    <link href="https://blog.silencew.cn/2020/03/06/python/02.%E5%85%B3%E9%97%AD%E7%A8%8B%E5%BA%8F/"/>
    <id>https://blog.silencew.cn/2020/03/06/python/02.关闭程序/</id>
    <published>2020-03-05T16:00:00.000Z</published>
    <updated>2020-05-18T12:01:30.530Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<a href="https://blog.csdn.net/yournevermore/article/details/89495327" target="_blank" rel="noopener">python 中杀进程 , 线程 ,杀端口</a></p><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>目前使用一个程序开启一个web server线程，但是使用<code>thread.join()</code>不能使这个web server结束。故有以下调查</p><a id="more"></a><h4 id="杀线程"><a href="#杀线程" class="headerlink" title="杀线程"></a>杀线程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_async_raise</span><span class="params">(tid, exctype)</span>:</span></span><br><span class="line">    <span class="string">"""raises the exception, performs cleanup if needed"""</span></span><br><span class="line">    tid = ctypes.c_long(tid)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> inspect.isclass(exctype):</span><br><span class="line">        exctype = type(exctype)</span><br><span class="line">    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, ctypes.py_object(exctype))</span><br><span class="line">    <span class="keyword">if</span> res == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">"invalid thread id"</span>)</span><br><span class="line">    <span class="keyword">elif</span> res != <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># """if it returns a number greater than one, you're in trouble,</span></span><br><span class="line">        <span class="comment"># and you should call it again with exc=NULL to revert the effect"""</span></span><br><span class="line">        ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">raise</span> SystemError(<span class="string">"PyThreadState_SetAsyncExc failed"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stop_thread</span><span class="params">(thread)</span>:</span></span><br><span class="line">    _async_raise(thread.ident, SystemExit)</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testClass</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,abc)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.out=abc</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            print(self.out)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_time</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        print(<span class="string">'234'</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    t = threading.Thread(target=print_time)</span><br><span class="line">    <span class="comment"># t = testClass('123')</span></span><br><span class="line">    t.daemon=<span class="literal">True</span></span><br><span class="line">    t.start()</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    print(t.is_alive())</span><br><span class="line">    stop_thread(t)</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    print(t.is_alive())</span><br><span class="line">    print(t.is_alive())</span><br><span class="line">    print(t.is_alive())</span><br><span class="line">    print(<span class="string">"stoped"</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h4 id="根据端口号关闭进程"><a href="#根据端口号关闭进程" class="headerlink" title="根据端口号关闭进程"></a>根据端口号关闭进程</h4><p>此处如果根据web server的端口来杀线程，并不能结束web server而保留原进程。而是把整个程序杀掉</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">killport</span><span class="params">(port)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    按端口号杀进程</span></span><br><span class="line"><span class="string">    :param port:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 查找端口的pid</span></span><br><span class="line">    find_port = <span class="string">'netstat -aon | findstr %s'</span> % str(port)</span><br><span class="line">    result = os.popen(find_port)</span><br><span class="line">    text = result.read()</span><br><span class="line">    pid = text.strip().split(<span class="string">' '</span>)[<span class="number">-1</span>]</span><br><span class="line">    <span class="comment"># 占用端口的pid</span></span><br><span class="line">    find_kill = <span class="string">'taskkill -f -pid %s'</span> % pid</span><br><span class="line">    print(find_kill)</span><br><span class="line">    result = os.popen(find_kill)</span><br><span class="line">    <span class="keyword">return</span> result.read()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载：&lt;a href=&quot;https://blog.csdn.net/yournevermore/article/details/89495327&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;python 中杀进程 , 线程 ,杀端口&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h4&gt;&lt;p&gt;目前使用一个程序开启一个web server线程，但是使用&lt;code&gt;thread.join()&lt;/code&gt;不能使这个web server结束。故有以下调查&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://blog.silencew.cn/categories/python/"/>
    
    
      <category term="python" scheme="https://blog.silencew.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python录制系统声音</title>
    <link href="https://blog.silencew.cn/2020/02/26/python/01.%E5%BD%95%E9%9F%B3/"/>
    <id>https://blog.silencew.cn/2020/02/26/python/01.录音/</id>
    <published>2020-02-25T16:00:00.000Z</published>
    <updated>2020-05-18T12:01:30.530Z</updated>
    
    <content type="html"><![CDATA[<p>转载：<a href="https://blog.csdn.net/littlezhuhui/article/details/101025305" target="_blank" rel="noopener">python开发的录音机（一）录制声卡播放的声音(内录)</a></p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>python</p><ul><li><code>wave</code></li><li><code>pyaudio</code></li></ul><p>wave 可以通过pip直接install，在安装<code>pyaudio</code>时，通过正常的pip install 直接安装一直处于报错阶段，后来想到可以通过轮子直接安装。</p><p>在<a href="https://pypi.org/project/PyAudio/#files" target="_blank" rel="noopener">pypi</a>提供的安装包中有对应的安装包，注意，不仅仅是<code>python2</code>和<code>python3</code>的区别，<code>python3</code>的小版本也有点差别。可杯具的是，小主电脑里装的是<code>python3.8</code>，后来想到还有一个网站可以安装<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#pyaudio" target="_blank" rel="noopener">pythonlibs</a>，找到对应的版本后，下载下来。直接在文件所在目录，或者在安装中指定文件目录中执行安装</p><a id="more"></a><p><code>pip install /c/Users/root/Downloads/PyAudio-0.2.11-cp38-cp38-win_amd64.whl</code></p><h2 id="代码和运行"><a href="#代码和运行" class="headerlink" title="代码和运行"></a>代码和运行</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">audio_record</span><span class="params">(out_file, rec_time)</span>:</span></span><br><span class="line">    CHUNK = <span class="number">1024</span></span><br><span class="line">    FORMAT = pyaudio.paInt16  <span class="comment"># 16bit编码格式</span></span><br><span class="line">    CHANNELS = <span class="number">1</span>  <span class="comment"># 单声道</span></span><br><span class="line">    RATE = <span class="number">16000</span>  <span class="comment"># 16000采样频率</span></span><br><span class="line">    p = pyaudio.PyAudio()</span><br><span class="line">    <span class="comment"># 创建音频流</span></span><br><span class="line">    dev_idx = findInternalRecordingDevice(p)</span><br><span class="line">    stream = p.open(format=FORMAT,  <span class="comment"># 音频流wav格式</span></span><br><span class="line">                    channels=CHANNELS,  <span class="comment"># 单声道</span></span><br><span class="line">                    rate=RATE,  <span class="comment"># 采样率16000</span></span><br><span class="line">                    input=<span class="literal">True</span>,</span><br><span class="line">                    input_device_index=dev_idx, <span class="comment"># 指定内录设备的id，可以不写，使用win的默认录音设备</span></span><br><span class="line">                    frames_per_buffer=CHUNK)</span><br><span class="line">    print(<span class="string">"Start Recording..."</span>)</span><br><span class="line">    frames = []  <span class="comment"># 录制的音频流</span></span><br><span class="line">    <span class="comment"># 录制音频数据</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, int(RATE / CHUNK * rec_time)): <span class="comment"># 控制录音时间</span></span><br><span class="line">        data = stream.read(CHUNK)</span><br><span class="line">        frames.append(data)</span><br><span class="line">    <span class="comment"># 录制完成</span></span><br><span class="line">    stream.stop_stream()</span><br><span class="line">    stream.close()</span><br><span class="line">    p.terminate()</span><br><span class="line">    print(<span class="string">"Recording Done..."</span>)</span><br><span class="line">    <span class="comment"># 保存音频文件</span></span><br><span class="line">    wf = wave.open(out_file, <span class="string">'wb'</span>)</span><br><span class="line">    wf.setnchannels(CHANNELS)</span><br><span class="line">    wf.setsampwidth(p.get_sample_size(FORMAT))</span><br><span class="line">    wf.setframerate(RATE)</span><br><span class="line">    wf.writeframes(<span class="string">b''</span>.join(frames))</span><br><span class="line">    wf.close()</span><br></pre></td></tr></table></figure><p>在使用默认录音设备时，发现是话筒录音，效果并不是太理想，所以就去查查能不能直接录系统的声音。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findInternalRecordingDevice</span><span class="params">(p)</span>:</span></span><br><span class="line">    <span class="comment"># 要找查的设备名称中的关键字</span></span><br><span class="line">    target = <span class="string">'立体声混音'</span></span><br><span class="line">    <span class="comment"># 逐一查找声音设备</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(p.get_device_count()):</span><br><span class="line">        devInfo = p.get_device_info_by_index(i)</span><br><span class="line">        print(devInfo)</span><br><span class="line">        <span class="keyword">if</span> devInfo[<span class="string">'name'</span>].find(target) &gt;= <span class="number">0</span> <span class="keyword">and</span> devInfo[<span class="string">'hostApi'</span>] == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># print('已找到内录设备,序号是 ',i)</span></span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    print(<span class="string">'无法找到内录设备!'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>可以使用<code>p.get_device_info_by_index()</code>去查看系统有关声音的设备，通过设置为立体声混音就可以录制系统声音。</p><h3 id="保存声音"><a href="#保存声音" class="headerlink" title="保存声音"></a>保存声音</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(fileName)</span>:</span></span><br><span class="line">    <span class="comment"># 创建pyAudio对象</span></span><br><span class="line">    p = pyaudio.PyAudio()</span><br><span class="line">    <span class="comment"># 打开用于保存数据的文件</span></span><br><span class="line">    wf = wave.open(fileName, <span class="string">'wb'</span>)</span><br><span class="line">    <span class="comment"># 设置音频参数</span></span><br><span class="line">    wf.setnchannels(CHANNELS)</span><br><span class="line">    wf.setsampwidth(p.get_sample_size(FORMAT))</span><br><span class="line">    wf.setframerate(RATE)</span><br><span class="line">    <span class="comment"># 写入数据</span></span><br><span class="line">    wf.writeframes(<span class="string">b''</span>.join(_frames))</span><br><span class="line">    <span class="comment"># 关闭文件</span></span><br><span class="line">    wf.close()</span><br><span class="line">    <span class="comment"># 结束pyaudio</span></span><br><span class="line">    p.terminate()</span><br></pre></td></tr></table></figure><p>保存声音是通过上述代码进行保存，此处的<code>_frames</code>是个list，是通过每录一个chunk（数据流块），就把这一块的数据添加进去</p><p>然后只需要重新创建<code>PyAudio</code>对象，把这个list转为字节串保存到文件中就可以了</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>上述一般可以录到系统声音，但在执行的时候发现，并不能。</p><p>原因是：win的输入设备中没有配置立体声混音</p><p>设置步骤：</p><ul><li>在win的声音调节出，右击打开声音设置</li><li>找到管理声音设备</li><li>在输入设备处启用立体声混音</li></ul><p>就此，就完成了录制系统声音的需求</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>上述操作，可以<code>外放</code>，可以<code>插入3.5mm耳机</code>，但<code>系统静音</code>和<code>tpye-c耳机插入</code>的时候<strong>不能录到声音</strong></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pyaudio</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> wave</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要系统打开立体声混音</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 录音类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Recorder</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, chunk=<span class="number">1024</span>, channels=<span class="number">2</span>, rate=<span class="number">44100</span>)</span>:</span></span><br><span class="line">        self.CHUNK = chunk</span><br><span class="line">        self.FORMAT = pyaudio.paInt16</span><br><span class="line">        self.CHANNELS = channels</span><br><span class="line">        self.RATE = rate</span><br><span class="line">        self._running = <span class="literal">True</span></span><br><span class="line">        self._frames = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取内录设备序号,在windows操作系统上测试通过，hostAPI = 0 表明是MME设备</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findInternalRecordingDevice</span><span class="params">(self, p)</span>:</span></span><br><span class="line">        <span class="comment"># 要找查的设备名称中的关键字</span></span><br><span class="line">        target = <span class="string">'立体声混音'</span></span><br><span class="line">        <span class="comment"># 逐一查找声音设备</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(p.get_device_count()):</span><br><span class="line">            devInfo = p.get_device_info_by_index(i)</span><br><span class="line">            <span class="comment"># print(devInfo)</span></span><br><span class="line">            <span class="keyword">if</span> devInfo[<span class="string">'name'</span>].find(target) &gt;= <span class="number">0</span> <span class="keyword">and</span> devInfo[<span class="string">'hostApi'</span>] == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># print('已找到内录设备,序号是 ',i)</span></span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        print(<span class="string">'无法找到内录设备!'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始录音，开启一个新线程进行录音操作</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        threading._start_new_thread(self.__record, ())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行录音的线程函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__record</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._running = <span class="literal">True</span></span><br><span class="line">        self._frames = []</span><br><span class="line"></span><br><span class="line">        p = pyaudio.PyAudio()</span><br><span class="line">        <span class="comment"># 查找内录设备</span></span><br><span class="line">        dev_idx = self.findInternalRecordingDevice(p)</span><br><span class="line">        <span class="keyword">if</span> dev_idx &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 在打开输入流时指定输入设备</span></span><br><span class="line">        stream = p.open(input_device_index=dev_idx,</span><br><span class="line">                        format=self.FORMAT,</span><br><span class="line">                        channels=self.CHANNELS,</span><br><span class="line">                        rate=self.RATE,</span><br><span class="line">                        input=<span class="literal">True</span>,</span><br><span class="line">                        frames_per_buffer=self.CHUNK)</span><br><span class="line">        <span class="comment"># 循环读取输入流</span></span><br><span class="line">        <span class="keyword">while</span> (self._running):</span><br><span class="line">            data = stream.read(self.CHUNK)</span><br><span class="line">            self._frames.append(data)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 停止读取输入流</span></span><br><span class="line">        stream.stop_stream()</span><br><span class="line">        <span class="comment"># 关闭输入流</span></span><br><span class="line">        stream.close()</span><br><span class="line">        <span class="comment"># 结束pyaudio</span></span><br><span class="line">        p.terminate()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 停止录音</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stop</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._running = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存到文件</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self, fileName)</span>:</span></span><br><span class="line">        <span class="comment"># 创建pyAudio对象</span></span><br><span class="line">        p = pyaudio.PyAudio()</span><br><span class="line">        <span class="comment"># 打开用于保存数据的文件</span></span><br><span class="line">        wf = wave.open(fileName, <span class="string">'wb'</span>)</span><br><span class="line">        <span class="comment"># 设置音频参数</span></span><br><span class="line">        wf.setnchannels(self.CHANNELS)</span><br><span class="line">        wf.setsampwidth(p.get_sample_size(self.FORMAT))</span><br><span class="line">        wf.setframerate(self.RATE)</span><br><span class="line">        <span class="comment"># 写入数据</span></span><br><span class="line">        wf.writeframes(<span class="string">b''</span>.join(self._frames))</span><br><span class="line">        <span class="comment"># 关闭文件</span></span><br><span class="line">        wf.close()</span><br><span class="line">        <span class="comment"># 结束pyaudio</span></span><br><span class="line">        p.terminate()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检测当前目录下是否有record子目录</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">'record'</span>):</span><br><span class="line">        os.makedirs(<span class="string">'record'</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"\npython 录音机 ....\n"</span>)</span><br><span class="line">    print(<span class="string">"提示：按 r 键并回车 开始录音\n"</span>)</span><br><span class="line"></span><br><span class="line">    i = input(<span class="string">'请输入操作码:'</span>)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="string">'r'</span>:</span><br><span class="line">        rec = Recorder()</span><br><span class="line">        begin = time.time()</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"\n开始录音,按 s 键并回车 停止录音，自动保存到 record 子目录\n"</span>)</span><br><span class="line">        rec.start()</span><br><span class="line"></span><br><span class="line">        running = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> running:</span><br><span class="line">            i = input(<span class="string">"请输入操作码:"</span>)</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">'s'</span>:</span><br><span class="line">                running = <span class="literal">False</span></span><br><span class="line">                print(<span class="string">"录音已停止"</span>)</span><br><span class="line">                rec.stop()</span><br><span class="line">                t = time.time() - begin</span><br><span class="line">                print(<span class="string">'录音时间为%ds'</span> % t)</span><br><span class="line">                <span class="comment"># 以当前时间为关键字保存wav文件</span></span><br><span class="line">                rec.save(<span class="string">"record/rec_"</span> + datetime.now().strftime(<span class="string">"%Y-%m-%d_%H-%M-%S"</span>) + <span class="string">".wav"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载：&lt;a href=&quot;https://blog.csdn.net/littlezhuhui/article/details/101025305&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;python开发的录音机（一）录制声卡播放的声音(内录)&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h2&gt;&lt;p&gt;python&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;wave&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pyaudio&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;wave 可以通过pip直接install，在安装&lt;code&gt;pyaudio&lt;/code&gt;时，通过正常的pip install 直接安装一直处于报错阶段，后来想到可以通过轮子直接安装。&lt;/p&gt;&lt;p&gt;在&lt;a href=&quot;https://pypi.org/project/PyAudio/#files&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pypi&lt;/a&gt;提供的安装包中有对应的安装包，注意，不仅仅是&lt;code&gt;python2&lt;/code&gt;和&lt;code&gt;python3&lt;/code&gt;的区别，&lt;code&gt;python3&lt;/code&gt;的小版本也有点差别。可杯具的是，小主电脑里装的是&lt;code&gt;python3.8&lt;/code&gt;，后来想到还有一个网站可以安装&lt;a href=&quot;https://www.lfd.uci.edu/~gohlke/pythonlibs/#pyaudio&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pythonlibs&lt;/a&gt;，找到对应的版本后，下载下来。直接在文件所在目录，或者在安装中指定文件目录中执行安装&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://blog.silencew.cn/categories/python/"/>
    
    
      <category term="python" scheme="https://blog.silencew.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>ES相关配置</title>
    <link href="https://blog.silencew.cn/2020/01/08/es/ES%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/"/>
    <id>https://blog.silencew.cn/2020/01/08/es/ES相关配置/</id>
    <published>2020-01-07T16:00:00.000Z</published>
    <updated>2020-05-18T12:01:30.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-设置最大返回条数"><a href="#1-设置最大返回条数" class="headerlink" title="1.设置最大返回条数"></a>1.设置最大返回条数</h2><p>在ElasticSearch中一般做分页查询，通过from和size进行实现，from指定从哪一行开始，size指定一次读取多少。</p><p>但是有时候需要返回较多的数据，并不知道具体的数量，所以需要将size设定的足够大，但是ES最大查询结果只能到10000，这个是因为es的配置中的<code>index.max_result_window</code>的最大默认值是10000。</p><a id="more"></a><p>需要修改该值（或添加）</p><p>首先查询配置项(这里我的index为platform)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET /<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9200</span>/platform/_settings</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"platform"</span>: &#123;</span><br><span class="line">        <span class="string">"settings"</span>: &#123;</span><br><span class="line">            <span class="string">"index"</span>: &#123;</span><br><span class="line">                <span class="string">"number_of_shards"</span>: <span class="string">"5"</span>,</span><br><span class="line">                <span class="string">"provided_name"</span>: <span class="string">"platform-alpha"</span>,</span><br><span class="line">                <span class="string">"creation_date"</span>: <span class="string">"1578477702787"</span>,</span><br><span class="line">                <span class="string">"number_of_replicas"</span>: <span class="string">"1"</span>,</span><br><span class="line">                <span class="string">"uuid"</span>: <span class="string">"gG9VqLXVQsG9dV3e9CATKA"</span>,</span><br><span class="line">                <span class="string">"version"</span>: &#123;</span><br><span class="line">                    <span class="string">"created"</span>: <span class="string">"5061699"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到并没有这个配置项，所以我们需要添加该配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9200</span>/platform/_settings</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"index"</span>: &#123;</span><br><span class="line"><span class="string">"max_result_window"</span>: <span class="number">2147483647</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>ES支持最大返回数目是<code>2 ^ 31 - 1</code>，也就是2147483647</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-设置最大返回条数&quot;&gt;&lt;a href=&quot;#1-设置最大返回条数&quot; class=&quot;headerlink&quot; title=&quot;1.设置最大返回条数&quot;&gt;&lt;/a&gt;1.设置最大返回条数&lt;/h2&gt;&lt;p&gt;在ElasticSearch中一般做分页查询，通过from和size进行实现，from指定从哪一行开始，size指定一次读取多少。&lt;/p&gt;&lt;p&gt;但是有时候需要返回较多的数据，并不知道具体的数量，所以需要将size设定的足够大，但是ES最大查询结果只能到10000，这个是因为es的配置中的&lt;code&gt;index.max_result_window&lt;/code&gt;的最大默认值是10000。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ES" scheme="https://blog.silencew.cn/categories/ES/"/>
    
    
      <category term="后端" scheme="https://blog.silencew.cn/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="ES" scheme="https://blog.silencew.cn/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>mysql存储过程</title>
    <link href="https://blog.silencew.cn/2019/12/25/db/mysql/08%E3%80%81%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    <id>https://blog.silencew.cn/2019/12/25/db/mysql/08、存储过程/</id>
    <published>2019-12-24T16:00:00.000Z</published>
    <updated>2020-05-18T12:01:30.503Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="使用存储过程"></a>使用存储过程</h3><p>MySQL称存储过程的执行为调用，因此MySQL执行存储过程的语句为CALL。CALL接受存储过程的名字以及需要传递给它的任意参数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> productpricing(@pricelow,</span><br><span class="line">@pricehigh,</span><br><span class="line">@priceaverage);</span><br></pre></td></tr></table></figure><p>执行名为<code>productpricing</code>的存储过程，计算返回产品的最低，最高和平均价格。</p><a id="more"></a><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一个返回产品平均价格的存储过程</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> productpricing()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Avg</span>(prod_price) <span class="keyword">AS</span> priceaverage</span><br><span class="line"><span class="keyword">FROM</span> products;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>上述代码创建一个名为<code>productpricing</code>的存储过程。如果存储过程接受参数，他们会在<code>()</code>中列举出来。</p><p>使用这个存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> productpricing(); <span class="comment">-- 执行刚创建的存储过程并显示返回的结果</span></span><br></pre></td></tr></table></figure><img src="/2019/12/25/db/mysql/08、存储过程/1577243294747.png" class="slug"><p><strong>存储过程实际上是一种函数</strong></p><h3 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h3><p>存储过程在创建之后，被保存在服务器上以供使用，直至被删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> productpricing;</span><br></pre></td></tr></table></figure><p>如果指定的过程不存在，则DROP PROCEDURE将产生一个错误。也可以使用<code>DROP PROCEDURE IF EXISTS</code></p><h3 id="使用参数"><a href="#使用参数" class="headerlink" title="使用参数"></a>使用参数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> productpricing(</span><br><span class="line"><span class="keyword">OUT</span> pl <span class="built_in">DECIMAL</span>(<span class="number">8</span>, <span class="number">2</span>),</span><br><span class="line"><span class="keyword">OUT</span> ph <span class="built_in">DECIMAL</span>(<span class="number">8</span>, <span class="number">2</span>),</span><br><span class="line"><span class="keyword">OUT</span> pa <span class="built_in">DECIMAL</span>(<span class="number">8</span>, <span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Min</span>(prod_price)</span><br><span class="line"><span class="keyword">INTO</span> p1</span><br><span class="line"><span class="keyword">FROM</span> products;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Max</span>(prod_price)</span><br><span class="line"><span class="keyword">INTO</span> ph</span><br><span class="line"><span class="keyword">FROM</span> products;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Avg</span>(prod_price)</span><br><span class="line"><span class="keyword">INTO</span> pa</span><br><span class="line"><span class="keyword">FROM</span> products;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">此存储过程接受3个参数：pl存储产品最低价格，ph存储产品最高价格，pa存储产品平均价格。每个参数必须具有指定的类型，这里使用十进制值。关键字OUT指出相应的参数用来从存储过程传出一个值（返回给调用者）。MySQL支持IN（传递给存储过程）、OUT(从存储过程传出)和INOUT（对存储过程传入和传出）类型的参数。</span></span><br><span class="line"><span class="comment">这里存储过程的代码是一系列的SELECT语句，用来检索值，然后保存到响应的变量（通过INTO关键字）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>所有的MySQL变量都必须以@开始</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CALL productpricing(@pricelow,</span><br><span class="line">@pricehigh,</span><br><span class="line">@priceaverage);</span><br><span class="line">SELECT @pricehigh, @pricelow, @priceaverage;</span><br></pre></td></tr></table></figure><img src="/2019/12/25/db/mysql/08、存储过程/1577244249734.png" class="slug"><p>下面使用IN和OUT参数，<code>ordertotal</code>接受订单号，并返回该订单的合计</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> ordertotal(</span><br><span class="line"><span class="keyword">IN</span> onumber <span class="built_in">INT</span>,</span><br><span class="line"><span class="keyword">OUT</span> ototal <span class="built_in">DECIMAL</span>(<span class="number">8</span>, <span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Sum</span>(item_price*quantity)</span><br><span class="line"><span class="keyword">FROM</span> orderitems</span><br><span class="line"><span class="keyword">WHERE</span> order_num = onumber</span><br><span class="line"><span class="keyword">INTO</span> ototal;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>调用这个存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> ordertotal(<span class="number">20005</span>, @total);</span><br><span class="line"><span class="keyword">SELECT</span> @total;</span><br></pre></td></tr></table></figure><h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><p>这样一个场景，需要获得与以前一样的订单合计，但需要对合计增加营业税，不过只针对某些顾客（或许是你所在州中那些顾客），那么需要做下面几件事：</p><ul><li>获得合计</li><li>把营业税有条件的添加到合计</li><li>返回合计</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Name: ordertotal</span></span><br><span class="line"><span class="comment">-- Parameters: onumber = order number</span></span><br><span class="line"><span class="comment">--    taxable = 0 if not taxable, 1 if taxable</span></span><br><span class="line"><span class="comment">--    ototal = order total variable</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> ordertotal(</span><br><span class="line"><span class="keyword">IN</span> onumber <span class="built_in">INT</span>,</span><br><span class="line">    <span class="keyword">IN</span> taxable <span class="built_in">BOOLEAN</span>,</span><br><span class="line">    <span class="keyword">OUT</span> ototal <span class="built_in">DECIMAL</span>(<span class="number">8</span>, <span class="number">2</span>)</span><br><span class="line">) <span class="keyword">COMMENT</span> <span class="string">'Obtain order total, optionally adding tax'</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">-- Declare variable for total</span></span><br><span class="line"><span class="keyword">DECLARE</span> total <span class="built_in">DECIMAL</span>(<span class="number">8</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">-- Declare tax percentage</span></span><br><span class="line"><span class="keyword">DECLARE</span> taxrate <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Get the order total</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Sum</span>(item_price*quantity)</span><br><span class="line"><span class="keyword">FROM</span> orderitems</span><br><span class="line"><span class="keyword">WHERE</span> order_num = onumber</span><br><span class="line"><span class="keyword">INTO</span> total;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Is this taxable?</span></span><br><span class="line">IF taxable THEN</span><br><span class="line"><span class="comment">-- Yes, so add taxrate to the total</span></span><br><span class="line"><span class="keyword">SELECT</span> total + (total/<span class="number">100</span>*taxrate) <span class="keyword">INTO</span> total;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="comment">-- And finally, save to out variable</span></span><br><span class="line"><span class="keyword">SELECT</span> total <span class="keyword">INTO</span> ototal;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>COMMENT关键字是不必需的，如果给出，将在<code>SHOW PROCEDURE STATUS</code> 的结果中显示</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> ordertotal(<span class="number">20005</span>, <span class="number">0</span>, @total);</span><br><span class="line"><span class="keyword">SELECT</span> @total;</span><br></pre></td></tr></table></figure><img src="/2019/12/25/db/mysql/08、存储过程/1577245465736.png" class="slug"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> ordertotal(<span class="number">20005</span>, <span class="number">1</span>, @total);</span><br><span class="line"><span class="keyword">SELECT</span> @total;</span><br></pre></td></tr></table></figure><img src="/2019/12/25/db/mysql/08、存储过程/1577245481482.png" class="slug"><h3 id="检查存储过程"><a href="#检查存储过程" class="headerlink" title="检查存储过程"></a>检查存储过程</h3><p>为显示用来创建一个存储过程的<code>CREATE</code>语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> ordertotal;</span><br></pre></td></tr></table></figure><p>为获得包括何时，由谁创建等详细信息的存储过程列表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PROCEDURE</span> <span class="keyword">STATUS</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 限制过程状态结果，可以用LIKE指定一个过滤模式</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PROCEDURE</span> <span class="keyword">STATUS</span> <span class="keyword">LIKE</span> <span class="string">'ordertotal'</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;使用存储过程&quot;&gt;&lt;a href=&quot;#使用存储过程&quot; class=&quot;headerlink&quot; title=&quot;使用存储过程&quot;&gt;&lt;/a&gt;使用存储过程&lt;/h3&gt;&lt;p&gt;MySQL称存储过程的执行为调用，因此MySQL执行存储过程的语句为CALL。CALL接受存储过程的名字以及需要传递给它的任意参数&lt;/p&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;CALL&lt;/span&gt; productpricing(@pricelow,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	@pricehigh,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	@priceaverage);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;执行名为&lt;code&gt;productpricing&lt;/code&gt;的存储过程，计算返回产品的最低，最高和平均价格。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://blog.silencew.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://blog.silencew.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
      <category term="后端" scheme="https://blog.silencew.cn/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="数据库" scheme="https://blog.silencew.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://blog.silencew.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql触发器</title>
    <link href="https://blog.silencew.cn/2019/12/25/db/mysql/10%E3%80%81%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <id>https://blog.silencew.cn/2019/12/25/db/mysql/10、触发器/</id>
    <published>2019-12-24T16:00:00.000Z</published>
    <updated>2020-05-18T12:01:30.507Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL语句在需要时被执行，存储过程也是。但如果想要某条语句在事件发生时自动执行，怎么办呢？</p><ul><li>每当增加一个顾客到某个数据库表时，都检查其电话号码的格式是否正确，州的缩写是否为大写</li><li>每当订购一个产品时，都从库存数量中减去订购的数量</li><li>无论何时删除一行，都在某个存档表中保留一个副本</li></ul><p>这些都需要在某个表发生更改时自动处理，就是触发器。</p><a id="more"></a><p>触发器是MySQL响应一下任意语句而自动执行的一条MySQL语句</p><ul><li>DELETE</li><li>INSERT</li><li>UPDATE</li></ul><h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h3><p>需要给出4条信息</p><ul><li>唯一的触发器名</li><li>触发器关联表</li><li><p>触发器应该响应的活动(DELETE, INSERT, UPDATE)</p></li><li><p>触发器何时执行</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> newproduct <span class="keyword">AFTER</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> products <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">SELECT</span> <span class="string">'Product added'</span>;</span><br></pre></td></tr></table></figure><p>CREATE TRIGGER用来创建名为newproduct的新触发器。触发器可在一个操作发生前或之后执行。这里给出了AFTER INSERT，所以此触发器将在INSERT语句成功执行后执行。这个触发器还指定FOR EACH ROW ，因此代码对每个插入行执行。这个例子中，文本Product added 将对每个插入的行显示一次。</p><p><strong>只有表才支持触发器，视图不支持</strong></p><p>触发器按每个表每个事件每次地定义，每个表每个事件每次只允许一个触发器。因此每个表最多支持6个触发器（每条INSERT、UPDATE、DELETE的之前和之后）。单一触发器不能与多个事件或多个表关联。所以，如果需要一个对INSERT和UPDATE操作执行的触发器，则应该定义两个触发器。</p><h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> newproduct;</span><br></pre></td></tr></table></figure><h3 id="使用触发器"><a href="#使用触发器" class="headerlink" title="使用触发器"></a>使用触发器</h3><h4 id="INSERT触发器"><a href="#INSERT触发器" class="headerlink" title="INSERT触发器"></a>INSERT触发器</h4><p>INSERT触发器在INSERT语句执行之前或之后执行。</p><ul><li>在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行</li><li>在BEFORE INSERT触发器中，NEW中的值也可以被更新（允许更改被插入的值）</li><li>对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自动生成值</li></ul><p>例：</p><ul><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> neworder <span class="keyword">AFTER</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> orders</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">SELECT</span> NEW.order_num;</span><br></pre></td></tr></table></figure><p>创建了一个名为neworder的触发器，按照AFTER INSERT ON orders执行。在插入一个新订单到orders表时，MySQL生成一个新订单号并保存到order_num中。触发器从NEW.order_num取得这个值并返回它。此触发器必须按照AFTER INSERT执行，因为在BEFORE INSERT语句执行之前，新的order_num还没有生成。对于orders的每次插入使用这个触发器将总是返回新的订单号。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(order_date, cust_id) <span class="keyword">VALUES</span>(<span class="keyword">Now</span>(), <span class="number">10001</span>);</span><br></pre></td></tr></table></figure><p>orders包含3个列，order_date和cust_id必须给出，order_num由MySQL自动生成，而现在order_num还自动被返回</p>  <img src="/2019/12/25/db/mysql/10、触发器/1577258795707.png" class="slug"></li></ul><h4 id="DELETE触发器"><a href="#DELETE触发器" class="headerlink" title="DELETE触发器"></a>DELETE触发器</h4><ul><li>在DELETE触发器代码内，可以引用一个名为OLD的虚拟表，访问被删除的行</li><li>OLD中的值全都是只读的，不能更新</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> deleteorder <span class="keyword">BEFORE</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> orders</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> archive_orders(order_num, order_date, cust_id) <span class="keyword">VALUES</span>(OLD.order_num, OLD.order_date, OLD.cust_id);</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>在任意订单被删除前，执行此触发器，将OLD中的值（要被删除的订单）保存到一个名为archive_orders的存档表中</p><h4 id="UPDATE触发器"><a href="#UPDATE触发器" class="headerlink" title="UPDATE触发器"></a>UPDATE触发器</h4><ul><li>在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问以前的（UPDATE语句前）的值，引用一个名为NEW的虚拟表访问新更新的值</li><li>在BEFORE UPDATE触发器中，NEW中的值可能也被更新（允许更改将要用于UPDATE语句中的值）</li><li>OLD中的值全都是只读的，不能更新</li></ul><p>下面的例子保证州名缩写总是大写：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> updatevendor <span class="keyword">BEFORE</span> <span class="keyword">UPDATE</span> <span class="keyword">ON</span> vendors</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">SET</span> NEW.vend_state = <span class="keyword">Upper</span>(NEW.vend_state);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL语句在需要时被执行，存储过程也是。但如果想要某条语句在事件发生时自动执行，怎么办呢？&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;每当增加一个顾客到某个数据库表时，都检查其电话号码的格式是否正确，州的缩写是否为大写&lt;/li&gt;
&lt;li&gt;每当订购一个产品时，都从库存数量中减去订购的数量&lt;/li&gt;
&lt;li&gt;无论何时删除一行，都在某个存档表中保留一个副本&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些都需要在某个表发生更改时自动处理，就是触发器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://blog.silencew.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://blog.silencew.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
      <category term="后端" scheme="https://blog.silencew.cn/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="数据库" scheme="https://blog.silencew.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://blog.silencew.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql游标</title>
    <link href="https://blog.silencew.cn/2019/12/25/db/mysql/09%E3%80%81%E6%B8%B8%E6%A0%87/"/>
    <id>https://blog.silencew.cn/2019/12/25/db/mysql/09、游标/</id>
    <published>2019-12-24T16:00:00.000Z</published>
    <updated>2020-05-18T12:01:30.506Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用游标"><a href="#使用游标" class="headerlink" title="使用游标"></a>使用游标</h3><ul><li>在能够使用游标前，必须先声明（定义）它，这个过程实际上没有检索数据，只是定义要使用的<code>SELECT</code>语句</li><li>一旦声明后，必须打开游标以供使用。这个过程用前面定义的<code>SELECT</code>语句把数据实际检索出来</li><li>对于填有数据的游标，根据需要取出（索引）各行</li><li>在结束游标使用时，必须关闭游标</li></ul><a id="more"></a><h4 id="创建游标"><a href="#创建游标" class="headerlink" title="创建游标"></a>创建游标</h4><p>游标用<code>DECLARE</code>语句创建，<code>DECLARE</code>命名游标，并定义相应的<code>SELECT</code>语句，根据需要带WHERE和其他子句。</p><p>下面的语句定义了名为<code>ordernumbers</code>的游标，使用了可以检索所有订单的<code>SELECT</code>语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> processorders()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> ordernumbers <span class="keyword">CURSOR</span></span><br><span class="line"><span class="keyword">FOR</span></span><br><span class="line"><span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> orders;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h4 id="打开和关闭游标"><a href="#打开和关闭游标" class="headerlink" title="打开和关闭游标"></a>打开和关闭游标</h4><p>打开游标</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPEN ordernumbers;</span><br></pre></td></tr></table></figure><p>关闭游标</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLOSE ordernumbers;</span><br></pre></td></tr></table></figure><p>隐含关闭</p><p>如果你不明确关闭游标，MySQL将会在到达END语句时自动关闭它。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> processorders()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">-- Declare the cursor</span></span><br><span class="line"><span class="keyword">DECLARE</span> ordernumbers <span class="keyword">CURSOR</span></span><br><span class="line"><span class="keyword">FOR</span></span><br><span class="line"><span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> orders;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Open the cursor</span></span><br><span class="line">OPEN ordernumbers;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Close the cursor</span></span><br><span class="line">CLOSE ordernumbers;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h4 id="使用游标数据"><a href="#使用游标数据" class="headerlink" title="使用游标数据"></a>使用游标数据</h4><p>在一个游标被打开后，可以使用FETCH语句分别访问它的每一行。FETCH指定检索什么数据（所需的列），检索出来的数据存储在什么地方。它还向前移动游标中的内部行指针，使用下一条FETCH语句检索下一行（不重复读取同一行）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> processorders()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">-- Declare local variables</span></span><br><span class="line"><span class="keyword">DECLARE</span> o <span class="built_in">INT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Declare the cursor</span></span><br><span class="line"><span class="keyword">DECLARE</span> ordernumbers <span class="keyword">CURSOR</span></span><br><span class="line"><span class="keyword">FOR</span></span><br><span class="line"><span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> orders;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Open the cursor</span></span><br><span class="line">OPEN ordernumbers;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Get order number</span></span><br><span class="line">FETCH ordernumbers INTO o; <span class="comment">-- 检索当前行的order_num列（将自动从第一行开始）到一个名为o的局部声明的变量中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Close the cursor</span></span><br><span class="line">CLOSE ordernumbers;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>下面一个例子，循环检索数据，从第一行到最后一行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> processorders()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">-- Declare local variables</span></span><br><span class="line"><span class="keyword">DECLARE</span> done <span class="built_in">BOOLEAN</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> o <span class="built_in">INT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Declare the cursor</span></span><br><span class="line"><span class="keyword">DECLARE</span> ordernumbers <span class="keyword">CURSOR</span></span><br><span class="line"><span class="keyword">FOR</span></span><br><span class="line"><span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> orders;</span><br><span class="line"><span class="comment">-- Declare continue handler</span></span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE <span class="keyword">HANDLER</span> <span class="keyword">FOR</span> <span class="keyword">SQLSTATE</span> <span class="string">'02000'</span> <span class="keyword">SET</span> done=<span class="number">1</span>;</span><br><span class="line"><span class="comment">-- Open the cursor</span></span><br><span class="line">OPEN ordernumbers;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Loop through all rows</span></span><br><span class="line">REPEAT</span><br><span class="line"><span class="comment">-- Get order number</span></span><br><span class="line">FETCH ordernumbers INTO o;</span><br><span class="line"><span class="comment">-- End of loop</span></span><br><span class="line">UNTIL done <span class="keyword">END</span> <span class="keyword">REPEAT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Close the cursor</span></span><br><span class="line">CLOSE ordernumbers;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>这个例子中的FETCH是在REPEAT内，因此它反复执行直到done为真（由UNTIL done END REPEAT;规定）。为使它起作用，用一个DEFAULT 0（假，不结束）定义变量done。</p><p>通过这个语句将done设为1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE CONTINUE HANDLER FOR SQLSTATE &apos;02000&apos; SET done=1;</span><br></pre></td></tr></table></figure><p>指当<code>SQLSTATE &#39;02000&#39;</code>出现时，SET done=1。这里<code>SQLSTATE &#39;02000&#39;</code>是一个未找到条件，当REPEAT由于没有更多行供循环而不能继续时，出现这个条件。</p><p>如果调用这个存储过程，它将定义几个变量和一个CONTINUE HANDLER，定义并打开一个游标，重复读取所有行，然后关闭游标。</p><p><strong>DECLARE语句的次序</strong>，DECLARE语句发布存在特定的次序。用DECLARE语句定义的局部变量必须在定义任意游标或句柄之前定义。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> processorders()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">-- Declare local variables</span></span><br><span class="line"><span class="keyword">DECLARE</span> done <span class="built_in">BOOLEAN</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> o <span class="built_in">INT</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> t <span class="built_in">DECIMAL</span>(<span class="number">8</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Declare the cursor</span></span><br><span class="line"><span class="keyword">DECLARE</span> ordernumbers <span class="keyword">CURSOR</span></span><br><span class="line"><span class="keyword">FOR</span></span><br><span class="line"><span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> orders;</span><br><span class="line"><span class="comment">-- Declare continue handler</span></span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE <span class="keyword">HANDLER</span> <span class="keyword">FOR</span> <span class="keyword">SQLSTATE</span> <span class="string">'02000'</span> <span class="keyword">SET</span> done=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Create a table to store the results</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> ordertotals(order_num <span class="built_in">INT</span>, total <span class="built_in">DECIMAL</span>(<span class="number">8</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Open the cursor</span></span><br><span class="line">OPEN ordernumbers;</span><br><span class="line"><span class="comment">-- Loop through all rows</span></span><br><span class="line">REPEAT</span><br><span class="line"><span class="comment">-- Get order number</span></span><br><span class="line">FETCH ordernumbers INTO O;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Get the total for this order</span></span><br><span class="line"><span class="keyword">CALL</span> ordertotal(o, <span class="number">1</span>, t)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Insert order and total into ordertotals</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> ordertotals(order_num, total) <span class="keyword">VALUES</span>(o, t);</span><br><span class="line"><span class="comment">-- End of loop</span></span><br><span class="line">UNTIL done <span class="keyword">END</span> <span class="keyword">REPEAT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Close the cursor</span></span><br><span class="line">CLOSE ordernumbers;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>这个例子中，增加了另一个名为t的变量，存储每个订单的合计。此存储过程还在运行中创建了一个新表（如果它不存在的话），名为<code>ordertotals</code>。这个表将保存存储过程生成的结果。FETCH像之前一样，取每个<code>order_num</code>，然后用CALL 执行另一个存储过程（在存储过程中创建的）来计算每个订单的带税合计，结果存储到t，最后用INSERT保存每个订单的订单号和合计。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ordertotals;</span><br></pre></td></tr></table></figure><img src="/2019/12/25/db/mysql/09、游标/1577257001907.png" class="slug">]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;使用游标&quot;&gt;&lt;a href=&quot;#使用游标&quot; class=&quot;headerlink&quot; title=&quot;使用游标&quot;&gt;&lt;/a&gt;使用游标&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在能够使用游标前，必须先声明（定义）它，这个过程实际上没有检索数据，只是定义要使用的&lt;code&gt;SELECT&lt;/code&gt;语句&lt;/li&gt;
&lt;li&gt;一旦声明后，必须打开游标以供使用。这个过程用前面定义的&lt;code&gt;SELECT&lt;/code&gt;语句把数据实际检索出来&lt;/li&gt;
&lt;li&gt;对于填有数据的游标，根据需要取出（索引）各行&lt;/li&gt;
&lt;li&gt;在结束游标使用时，必须关闭游标&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://blog.silencew.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://blog.silencew.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
      <category term="后端" scheme="https://blog.silencew.cn/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="数据库" scheme="https://blog.silencew.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://blog.silencew.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql视图</title>
    <link href="https://blog.silencew.cn/2019/12/24/db/mysql/07%E3%80%81%E8%A7%86%E5%9B%BE/"/>
    <id>https://blog.silencew.cn/2019/12/24/db/mysql/07、视图/</id>
    <published>2019-12-23T16:00:00.000Z</published>
    <updated>2020-05-18T12:01:30.501Z</updated>
    
    <content type="html"><![CDATA[<p>视图是虚拟的表，只包含使用时动态检索的查询</p><p>例如：下面的语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact </span><br><span class="line"><span class="keyword">FROM</span> customers, orders, orderitems </span><br><span class="line"><span class="keyword">WHERE</span> customers.cust_id = orders.cust_id <span class="keyword">AND</span> orderitems.order_num = orders.order_num <span class="keyword">AND</span> prod_id = <span class="string">'TNT2'</span>;</span><br></pre></td></tr></table></figure><a id="more"></a><p>这个查询用来检索订购了某个特定产品的客户。任何需要这个数据的人都必须理解相关表的结构，并且知道如何创建查询和对表进行联结。为了检索其他产品（或多个产品）的相同数据，必须修改最后的WHERE子句。</p><p>使用视图后，语句变成</p><p><code>SELECT cust_name, cust_contact FROM productcustomers WHERE prod_id = &#39;TNT2&#39;;</code> 其中，<code>productcustomers</code>是一个视图</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>重用SQL语句</li><li>简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节</li><li>使用表的组成部分而不是整个表</li><li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限</li><li>更改数据格式和表示。视图可以返回与底层表的表示和格式不同的数据</li></ul><p>视图仅仅是用来查看存储在别处的数据的一种设施，视图本身不包含数据，因此它们返回的数据是从其他表中检索出来的。在添加或更改这些表中的数据时，视图将返回改变过的数据。</p><p><strong>性能问题：</strong>因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时所需的任一个检索。如果用了多个联结和过滤创建了复杂的视图，可能会发现性能下降的厉害。</p><h3 id="视图的规则和限制"><a href="#视图的规则和限制" class="headerlink" title="视图的规则和限制"></a>视图的规则和限制</h3><ul><li>与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）</li><li>对于可以创建的视图数目没有限制</li><li>为了创建视图，必须具有足够的访问权限。这些限制通常由数据库管理人员授予</li><li>视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图</li><li><code>ORDER BY</code>可以用在视图中，但如果从该视图检索数据的<code>SELECT</code>语句中也含有<code>ORDER BY</code>，那么该视图中的<code>ORDER BY</code>将被覆盖</li><li>视图不能索引，也不能有关联的触发器或默认值</li><li>视图可以和表一起使用，例如，编写一条联结表和视图的<code>SELECT</code>语句</li></ul><h3 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h3><ul><li><p>利用视图简化复杂的联结</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> productcustomers <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact, prod_id </span><br><span class="line"><span class="keyword">FROM</span> customers, orders, orderitems </span><br><span class="line"><span class="keyword">WHERE</span> customers.cust_id = orders.cust_id <span class="keyword">AND</span> orderitems.order_num = orders.order_num;</span><br></pre></td></tr></table></figure><p>  这条语句创建一个名为<code>productcustomers</code>的视图，它联结三个表，以返回已订购了任意产品的所有客户的列表。如果执行<code>SELECT * FROM productcustomers;</code>，将列出订购了任意产品的客户。</p><p>  为了检索订购了产品<code>TNT2</code>的客户，可进行下面查询</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact </span><br><span class="line"><span class="keyword">FROM</span> productcustomers</span><br><span class="line"><span class="keyword">WHERE</span> prod_id = <span class="string">'TNT2'</span>;</span><br></pre></td></tr></table></figure>  <img src="/2019/12/24/db/mysql/07、视图/1577238271319.png" class="slug"></li><li><p>用视图重新格式化检索出的数据</p><p>  普通<code>sql</code></p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Contact(<span class="keyword">RTrim</span>(vend_name), <span class="string">' ('</span>, <span class="keyword">RTrim</span>(vend_country), <span class="string">')'</span>) <span class="keyword">AS</span> vend_title</span><br><span class="line"><span class="keyword">FROM</span> vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br></pre></td></tr></table></figure>  <img src="/2019/12/24/db/mysql/07、视图/1577238436928.png" class="slug"><p>  如果经常需要这个格式的结果，不必在每次需要时执行联结，创建一个视图，每次需要时使用它即可</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> vendorlocations <span class="keyword">AS</span> <span class="keyword">SELECT</span> Contact(<span class="keyword">RTrim</span>(vend_name), <span class="string">' ('</span>, <span class="keyword">RTrim</span>(vend_country), <span class="string">')'</span>) <span class="keyword">AS</span> vend_title</span><br><span class="line"><span class="keyword">FROM</span> vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>利用视图过滤不想要的数据</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> customeremaillist <span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> cust_id, cust_name, cust_email</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_email <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>  如果在视图检索数据时使用了一条WHERE子句，则两组子句（一组在视图中，另一组是传递给视图的）将自动组合</p></li><li><p>使用视图与计算字段</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREAET VIEW orderitemsexpanded AS </span><br><span class="line"><span class="keyword">SELECT</span> order_num,</span><br><span class="line">prod_id,</span><br><span class="line">quantity,</span><br><span class="line">item_price,</span><br><span class="line">quantity * item_price <span class="keyword">AS</span> expanded_price</span><br><span class="line"><span class="keyword">FROM</span> orderitems;</span><br></pre></td></tr></table></figure></li></ul><h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><p>通常，视图是可更新的（可以对它们使用<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>）。更新一个视图将更新其基表，如果你对视图增加或删除行，实际上是对其基表增加或删除行。</p><p>但是，并非所有的视图都是可更新的。如果MySQL不能正确地确定被更新的基数据，则不允许更新。这意味着，当视图定义中有以下操作，则不能进行视图更新：</p><ul><li>分组（使用<code>GROUP BY</code> 和 <code>HAVING</code>）</li><li>联结</li><li>子查询</li><li>并</li><li>聚集函数（<code>Min()</code>, <code>Count()</code>, <code>Sum()</code>等）</li><li><code>DISTINCT</code></li><li>导出（计算）列</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;视图是虚拟的表，只包含使用时动态检索的查询&lt;/p&gt;&lt;p&gt;例如：下面的语句&lt;/p&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;SELECT&lt;/span&gt; cust_name, cust_contact &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; customers, orders, orderitems &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;WHERE&lt;/span&gt; customers.cust_id = orders.cust_id &lt;span class=&quot;keyword&quot;&gt;AND&lt;/span&gt; orderitems.order_num = orders.order_num &lt;span class=&quot;keyword&quot;&gt;AND&lt;/span&gt; prod_id = &lt;span class=&quot;string&quot;&gt;&#39;TNT2&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://blog.silencew.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://blog.silencew.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
      <category term="后端" scheme="https://blog.silencew.cn/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="数据库" scheme="https://blog.silencew.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://blog.silencew.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>linux升级node版本</title>
    <link href="https://blog.silencew.cn/2019/12/23/javascript/nodejs/07%E3%80%81linux%E5%8D%87%E7%BA%A7node%E7%89%88%E6%9C%AC/"/>
    <id>https://blog.silencew.cn/2019/12/23/javascript/nodejs/07、linux升级node版本/</id>
    <published>2019-12-22T16:00:00.000Z</published>
    <updated>2020-05-18T12:01:30.526Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>在docker容器中启动node项目，但不希望每次都要<code>npm i</code>，所以要把源代码采用挂载的方式，放在镜像中。</p><p>需要在服务器中<code>npm i</code>，之后启动容器，结果报错了，原因是node版本不对。</p><p>后来采用了先挂载安装包，后再启动容器。</p><p>其实我们可以选择升级一下本地主机的node版本就方便多了</p><h4 id="升级node"><a href="#升级node" class="headerlink" title="升级node"></a>升级node</h4><p><code>node -v</code></p><a id="more"></a><ol><li><p>首先清理npm的缓存</p><p><code>npm cache clean -f</code></p></li><li><p>安装版本管理工具</p><p><code>npm install -g n</code></p></li><li><p>更新到最新的版本</p><p><code>n latest</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n 常用的命令有：</span><br><span class="line">n 会列出所有安装的版本供你切换</span><br><span class="line">n latest 安装最新版本</span><br><span class="line">n stable 安装最新稳定版</span><br><span class="line">n lts 安装最新长期支持版本</span><br><span class="line">n rm [版本号] 删除某一版本</span><br><span class="line">n -h 帮助命令</span><br><span class="line">n [版本号] 安装指定版本node</span><br></pre></td></tr></table></figure></li><li><p>查看node安装路径</p><p><code>which node</code></p></li><li><p>配置环境</p><p><code>vim ~/.bash_profile</code></p><p>添加下面语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export N_PREFIX=/usr/local/node-v7.10.0-linux-x64 #第4步显示的路径</span><br><span class="line">export PATH=$N_PREFIX/bin:$PATH</span><br></pre></td></tr></table></figure></li><li><p>执行source使修改生效</p><p><code>source ~/.bash_profile</code></p></li><li><p>检查node，如果版本已更新，那就配置结束，如果未更新，则执行以下语句</p><p><code>n stable</code></p></li></ol><h4 id="升级npm"><a href="#升级npm" class="headerlink" title="升级npm"></a>升级npm</h4><p><code>npm i -g npm</code> 或者指定npm 版本 <code>npm i -g npm@5.0.0</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h4&gt;&lt;p&gt;在docker容器中启动node项目，但不希望每次都要&lt;code&gt;npm i&lt;/code&gt;，所以要把源代码采用挂载的方式，放在镜像中。&lt;/p&gt;&lt;p&gt;需要在服务器中&lt;code&gt;npm i&lt;/code&gt;，之后启动容器，结果报错了，原因是node版本不对。&lt;/p&gt;&lt;p&gt;后来采用了先挂载安装包，后再启动容器。&lt;/p&gt;&lt;p&gt;其实我们可以选择升级一下本地主机的node版本就方便多了&lt;/p&gt;&lt;h4 id=&quot;升级node&quot;&gt;&lt;a href=&quot;#升级node&quot; class=&quot;headerlink&quot; title=&quot;升级node&quot;&gt;&lt;/a&gt;升级node&lt;/h4&gt;&lt;p&gt;&lt;code&gt;node -v&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://blog.silencew.cn/categories/javascript/"/>
    
      <category term="nodejs" scheme="https://blog.silencew.cn/categories/javascript/nodejs/"/>
    
    
      <category term="后端" scheme="https://blog.silencew.cn/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="javascript" scheme="https://blog.silencew.cn/tags/javascript/"/>
    
      <category term="nodejs" scheme="https://blog.silencew.cn/tags/nodejs/"/>
    
      <category term="linux" scheme="https://blog.silencew.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>mysql组合查询</title>
    <link href="https://blog.silencew.cn/2019/12/19/db/mysql/05%E3%80%81%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2/"/>
    <id>https://blog.silencew.cn/2019/12/19/db/mysql/05、组合查询/</id>
    <published>2019-12-18T16:00:00.000Z</published>
    <updated>2020-05-18T12:01:30.491Z</updated>
    
    <content type="html"><![CDATA[<h4 id="使用UNION"><a href="#使用UNION" class="headerlink" title="使用UNION"></a>使用UNION</h4><p>多数<code>SQL</code>查询都只包含一个或多个表中返回数据的单条<code>SELECT</code>语句。<code>MySQL</code>也允许执行多个查询(多条<code>SELECT</code>语句)，并将结果作为单个查询结果集返回。这些组合查询通常称为并(<code>union</code>)</p><p>有两种情况需要使用组合查询：</p><ul><li>在单个表查询中从不同的表返回类似结构的数据；</li><li>对单个表执行多个查询，按单个查询返回数据。</li></ul><a id="more"></a><p>组合查询和多个<code>WHERE</code>条件：多数情况下，组合相同表的两个查询完成的工作与具有多个WHERE子句条件的单条查询完成的工作相同。</p><p>可用<code>UNION</code>操作符来组合数条<code>SQL</code>查询，所需要做的就是给出每条<code>SELECT</code>语句，在各条语句之间放上关键字<code>UNION</code></p><p>例如：</p><p>​    假设需要价格小于等于5的所有物品的一个列表，而且还想包括供应商1001和1002生产的所有物品，当然可以利用<code>WHERE</code>子句来完成，不过这里我们使用<code>UNION</code></p><ul><li><p>这里是两条语句的组合</p><p><code>SELECT vend_id, prod_id, prod_price FROM products WHERE prod_price &lt;= 5;</code></p><img src="/2019/12/19/db/mysql/05、组合查询/1576736299670.png" class="slug"><p><code>SELECT vend_id, prod_id, prod_price FROM products WHERE vend_id IN (1001, 1002);</code></p><img src="/2019/12/19/db/mysql/05、组合查询/1576736376257.png" class="slug"></li><li><p>可以使用下面的语句</p><p><code>SELECT vend_id, prod_id, prod_price FROM products WHERE prod_price &lt;= 5 UNION SELECT vend_id, prod_id, prod_price FROM products WHERE vend_id IN (1001, 1002);</code></p><img src="/2019/12/19/db/mysql/05、组合查询/1576736514904.png" class="slug"></li><li><p>同样，可以使用<code>WHERE</code>子句</p><p><code>SELECT vend_id, prod_id, prod_price FROM products WHERE prod_price &lt;= 5 OR vend_id IN (1001, 1002);</code></p></li></ul><h4 id="UNION规则"><a href="#UNION规则" class="headerlink" title="UNION规则"></a>UNION规则</h4><ul><li>UNION必须由两条或两条以上的<code>SELECT</code>语句组成，语句之间用关键字<code>UNION</code>分隔</li><li>UNION中的每个查询必须包含相同的列、表达式或聚集函数（各个列不需要以相同的次序列出）</li><li>列数据烈性必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型（不同数值类型或不同的日期类型）</li></ul><h4 id="包含或取消重复的行"><a href="#包含或取消重复的行" class="headerlink" title="包含或取消重复的行"></a>包含或取消重复的行</h4><p>UNION会从查询的结果集中自动去除重复的行，如果想返回所有匹配行，可使用<code>UNION ALL</code></p><p><code>SELECT vend_id, prod_id, prod_price FROM products WHERE prod_price &lt;= 5 UNION ALL SELECT vend_id, prod_id, prod_price FROM products WHERE vend_id IN (1001, 1002);</code></p><img src="/2019/12/19/db/mysql/05、组合查询/1576737338677.png" class="slug"><h4 id="对组合查询结果排序"><a href="#对组合查询结果排序" class="headerlink" title="对组合查询结果排序"></a>对组合查询结果排序</h4><p>SELECT语句的输出用<code>ORDER BY</code>子句排序，在用<code>UNION</code>组合查询时，只能使用一条<code>ORDER BY</code>子句。它必须出现在最后一条<code>SELECT</code>语句之后。不允许使用多条<code>ORDER BY</code>子句。</p><p><code>SELECT vend_id, prod_id, prod_price FROM products WHERE prod_price &lt;= 5 UNION SELECT vend_id, prod_id, prod_price FROM products WHERE vend_id IN (1001, 1002) ORDER BY vend_id, prod_price;</code></p><img src="/2019/12/19/db/mysql/05、组合查询/1576737782438.png" class="slug">]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;使用UNION&quot;&gt;&lt;a href=&quot;#使用UNION&quot; class=&quot;headerlink&quot; title=&quot;使用UNION&quot;&gt;&lt;/a&gt;使用UNION&lt;/h4&gt;&lt;p&gt;多数&lt;code&gt;SQL&lt;/code&gt;查询都只包含一个或多个表中返回数据的单条&lt;code&gt;SELECT&lt;/code&gt;语句。&lt;code&gt;MySQL&lt;/code&gt;也允许执行多个查询(多条&lt;code&gt;SELECT&lt;/code&gt;语句)，并将结果作为单个查询结果集返回。这些组合查询通常称为并(&lt;code&gt;union&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;有两种情况需要使用组合查询：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在单个表查询中从不同的表返回类似结构的数据；&lt;/li&gt;
&lt;li&gt;对单个表执行多个查询，按单个查询返回数据。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://blog.silencew.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://blog.silencew.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
      <category term="后端" scheme="https://blog.silencew.cn/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="数据库" scheme="https://blog.silencew.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://blog.silencew.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql全文本搜索</title>
    <link href="https://blog.silencew.cn/2019/12/19/db/mysql/06%E3%80%81%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/"/>
    <id>https://blog.silencew.cn/2019/12/19/db/mysql/06、全文本搜索/</id>
    <published>2019-12-18T16:00:00.000Z</published>
    <updated>2020-05-18T12:01:30.495Z</updated>
    
    <content type="html"><![CDATA[<h4 id="理解全文本搜索"><a href="#理解全文本搜索" class="headerlink" title="理解全文本搜索"></a>理解全文本搜索</h4><p>并非所有引擎都支持全文本搜索：<code>MySQL</code>最常用的引擎<code>MyISAM</code>和<code>InnoDB</code>，前者支持全文本索引，后者不支持。</p><ul><li><code>LIKE</code>关键字利用通配操作符匹配文本（和部分文本），能够查找包含特殊值或部分值的行</li><li>正则表达式，可以编写查找所需行的非常复杂的匹配模式</li></ul><p>虽然以上搜索机制非常有用，但存在几个重要的限制。</p><a id="more"></a><ul><li>性能——通配符和正则表达式匹配通常要求<code>MySQL</code>尝试匹配表中所有行（而且这些搜索极少使用表索引）。因此，由于被搜索行数不断增加，这些搜索可能非常耗时。</li><li>明确控制——使用通配符和正则表达式匹配，很难（而且并不总是能）明确地控制匹配什么和不匹配什么。例如，指定一个词必须匹配，一个词必须不匹配，而一个词仅在第一个词确实匹配的情况下，才可以匹配或者才可以不匹配。</li><li>智能化的结果——虽然基于通配符和正则表达式的搜索提供了非常灵活的搜索，但他们都不能提供一种智能化选择结果的方法。</li></ul><h4 id="使用全文本搜索"><a href="#使用全文本搜索" class="headerlink" title="使用全文本搜索"></a>使用全文本搜索</h4><p>为了进行全文本搜索，必须索引被搜索的列，而且要随着数据的改变不断地重新索引，在对表列进行适当设计后，MySQL会自动进行所有的索引和重新索引。</p><p>在索引之后，<code>SELECT</code>可与<code>Match()</code>和<code>Against()</code>一起使用以实际执行搜索。</p><h5 id="启用全文本搜索支持"><a href="#启用全文本搜索支持" class="headerlink" title="启用全文本搜索支持"></a>启用全文本搜索支持</h5><p>一般在创建表时启用全文本搜索。<code>CREATE TABLE</code>语句接受<code>FULLTEXT子句</code>，它给出一个被索引列的一个逗号分隔的列表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> productnotes</span><br><span class="line">(</span><br><span class="line">note_id <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    prod_id <span class="built_in">char</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    note_date datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    note_text <span class="built_in">text</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(note_id),</span><br><span class="line">    FULLTEXT(note_text)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM;</span><br></pre></td></tr></table></figure><p>这里<code>FULLTEXT</code>索引单个列，如果需要也可以指定多个列。</p><p>在定义之后，MySQL自动维护该索引。在增加、更新或删除行时，索引随之自动更新。</p><p>可以在创建表时指定<code>FULLTEXT</code>,或者在稍后指定（在这种情况下所有已有数据必须立即索引）</p><h5 id="进行全文本搜索"><a href="#进行全文本搜索" class="headerlink" title="进行全文本搜索"></a>进行全文本搜索</h5><p>在索引之后，使用两个函数<code>Match()</code>和<code>Against()</code>执行全文本搜索，其中<code>Match()</code>指定被搜索的列，<code>Against()</code>指定要使用的搜索表达式。</p><p><code>SELECT note_text FROM productnotes WHERE Match(note_text) Against(&#39;rabbit&#39;);</code></p><img src="/2019/12/19/db/mysql/06、全文本搜索/1576740605746.png" class="slug"><p><strong>注意：</strong></p><ul><li><p>传递给<code>Match()</code>的值必须与<code>FULLTEXT()</code>定义中的相同。如果指定多个列，则必须列出它们（而且次序正确）。</p></li><li><p>除非使用<code>BINARY</code>方式，否则全文本搜索不区分大小写。</p></li></ul><p>上述语句也可以用LIKE完成：</p><p><code>SELECT note_text FROM productnotes WHERE note_text LIKE &#39;%rabbit%&#39;;</code></p><img src="/2019/12/19/db/mysql/06、全文本搜索/1576740906705.png" class="slug"><p>上述两条<code>SELECT</code>语句都不包含ORDER BY子句，后者（使用LIKE）以不特别有用的顺序返回。前者（使用全文本搜索）返回以文本匹配的良好程度排序的数据。两行都包含rabbit，但包含词rabbit作为第三个词的行的等级比作为第20个词的行高。</p><h5 id="使用查询扩展"><a href="#使用查询扩展" class="headerlink" title="使用查询扩展"></a>使用查询扩展</h5><p>查询扩展用来设法放宽所返回的全文本搜索结果的范围。考虑下面的情况，想找出所有提到anvils的注释。只有一个注释包含词anvils，但你还想找出可能与你的搜索有关的所有其他行，即使它们不包含词anvils</p><p>在使用查询扩展时，MySQL对数据和索引进行两遍扫描来完成搜索</p><ul><li>首先，进行一个基本的全文本搜索，找出与搜索条件匹配的所有行</li><li>其次，MySQL检查这些匹配行并选择所有有用的词</li><li>再其次，MySQL再次进行全文本搜索，这次不仅使用原来的条件，而且还使用所有有用的词。</li></ul><p><strong>注意：</strong>只用于MySQL 4.1.1或更高的版本</p><p>例：</p><ul><li><p>一个简单的全文本搜索</p><p><code>SELECT note_text FROM productnotes WHERE Match(note_text) Against(&#39;anvils&#39;);</code></p></li></ul><img src="/2019/12/19/db/mysql/06、全文本搜索/1576741814955.png" class="slug"><ul><li><p>相同的搜索，这次使用查询扩展</p><p><code>SELECT note_text FROM productnotes WHERE Match(note_text) Against (&#39;anvils&#39; WITH QUERY EXPANSION);</code></p><img src="/2019/12/19/db/mysql/06、全文本搜索/1576741922008.png" class="slug"><p>查询扩展极大地增加了返回的行数，但这样做也增加了实际上并不想要的行的数目。</p></li></ul><h5 id="布尔文本搜索"><a href="#布尔文本搜索" class="headerlink" title="布尔文本搜索"></a>布尔文本搜索</h5><p>  MySQL支持全文本搜索的另外一种形势，成为布尔方式。以布尔方式，可以提供关于如下内容的细节：</p><ul><li>要匹配的词；</li><li>要排斥的词</li><li>排列提示</li><li>表达式分组</li><li>另外一些内容</li></ul><p><strong>布尔方式即使没有定义<code>FULLTEXT</code>索引，也可以使用，但这是一种非常缓慢的操作</strong>（其性能将随数据量的增加而降低）</p><p><code>SELECT note_text FROM productnotes WHERE Match(note_text) Against(&#39;heavy&#39; IN BOOLEAN MODE);</code></p><img src="/2019/12/19/db/mysql/06、全文本搜索/1576742785358.png" class="slug"><p><strong>分析：</strong>此全文搜索检索包含词heavy的所有行（有两行）。其中使用了关键字IN BOOLEAN MODE，但实际上没有指定布尔操作符，因此，其结果与没有指定布尔方式的结果相同。</p><p>匹配包含heavy但不包含任意以rope开始的词的行</p><p><code>SELECT note_text FROM productnotes WHERE Match(note_text) Against(&#39;heavy -rope*&#39; IN BOOLEAN MODE);</code></p><img src="/2019/12/19/db/mysql/06、全文本搜索/1576743093108.png" class="slug"><p>这次只返回一行。这一次仍然匹配词heavy，但<code>-rope*</code>明确地指示MySQL排除包含rope*(任何以rope开始的词，包括ropes)的行，这就是为什么上一个例子中的第一行被排除的原因。</p><p> <strong>附：</strong>如果使用的是<code>MySQL 4.x</code>则上面的例子可能不返回任何行。在<code>MySQL 4.x</code>使用这个例子，使用<code>-ropes</code>而不是<code>-rope*</code>(排除ropes而不是排除任何以rope开始的词)。</p><div class="table-container"><table><thead><tr><th>布尔操作符</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td>包含，词必须存在</td></tr><tr><td>-</td><td>排除，词必须不出现</td></tr><tr><td>&gt;</td><td>包含，而且增加等级值</td></tr><tr><td>&lt;</td><td>包含，且减少等级值</td></tr><tr><td>()</td><td>把词组成子表达式（允许这些子表达式作为一个组被包含、排除、排列等）</td></tr><tr><td>~</td><td>取消一个词的排序值</td></tr><tr><td>*</td><td>词尾的通配符</td></tr><tr><td>“”</td><td>定义一个短语（与单词的列表不一样，它匹配整个短语以便包含或排除这个短语）</td></tr></tbody></table></div><p>下面举例说明操作符如何使用</p><ul><li><p><code>SELECT note_text FROM productnotes WHERE Match(note_text) Against(&#39;+rabbit +bait&#39; IN BOOLEAN MODE);</code></p><p>搜索匹配包含词rabbit和bait的行</p></li><li><p><code>SELECT note_text FROM productnotes WHERE Match(note_text) Against(&#39;rabbit bait&#39; IN BOOLEAN MODE);</code></p><p>没有指定操作符，这个搜索匹配包含rabbit和bait中至少一个词的行</p></li><li><p><code>SELECT note_text FROM productnotes WHERE Match(note_text) Against(&#39;&quot;rabbit bait&quot;&#39; IN BOOLEAN MODE);</code></p><p>搜索匹配短语rabbit bait 而不是匹配两个词</p></li><li><p><code>SELECT note_text FROM productnotes WHERE Match(note_text) Against(&#39;&gt;rabbit &lt;carrot&#39; IN BOOLEAN MODE);</code></p><p>匹配rabbit和carrot，增加前者的等级，降低后者的等级。</p></li><li><p><code>SELECT note_text FROM productnotes WHERE Match(note_text) Against(&#39;+safe +(&lt;combination)&#39; IN BOOLEAN MODE);</code></p><p>搜索匹配词safe和combination，降低后者的等级</p></li></ul><h4 id="全文本搜索的使用说明"><a href="#全文本搜索的使用说明" class="headerlink" title="全文本搜索的使用说明"></a>全文本搜索的使用说明</h4><ul><li>在索引全文本数据时，短词被忽略且从索引中排除。短语定义为那些具有3个或3个一下字符的词（如果需要，这个数目可以更改）。</li><li>MySQL带有一个内建的非用词（stopword）列表，这些词在索引全文本数据时总是被忽略。如果需要，可以覆盖这个列表</li><li>许多词出现的频率很高，搜索它们没有用处（返回太多的结果）。因此，MySQL规定了一条50%规则，如果一个词出现在50%以上的行中，则将它作为一个非用词忽略。50%规则不用于IN BOOLEAN MODE</li><li>如果表中的行数少于3行，则全文本搜索不返回结果（因为每个词或者不出现，或者至少出现在50%的行中）</li><li>忽略词中的单引号，例如，don’t索引为dont</li><li>不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文本搜索结果</li><li>仅在MyISAM数据库引擎中支持全文本搜索。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;理解全文本搜索&quot;&gt;&lt;a href=&quot;#理解全文本搜索&quot; class=&quot;headerlink&quot; title=&quot;理解全文本搜索&quot;&gt;&lt;/a&gt;理解全文本搜索&lt;/h4&gt;&lt;p&gt;并非所有引擎都支持全文本搜索：&lt;code&gt;MySQL&lt;/code&gt;最常用的引擎&lt;code&gt;MyISAM&lt;/code&gt;和&lt;code&gt;InnoDB&lt;/code&gt;，前者支持全文本索引，后者不支持。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;LIKE&lt;/code&gt;关键字利用通配操作符匹配文本（和部分文本），能够查找包含特殊值或部分值的行&lt;/li&gt;
&lt;li&gt;正则表达式，可以编写查找所需行的非常复杂的匹配模式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;虽然以上搜索机制非常有用，但存在几个重要的限制。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://blog.silencew.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://blog.silencew.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
      <category term="后端" scheme="https://blog.silencew.cn/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="数据库" scheme="https://blog.silencew.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://blog.silencew.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql数据分组</title>
    <link href="https://blog.silencew.cn/2019/12/13/db/mysql/04%E3%80%81%E6%95%B0%E6%8D%AE%E5%88%86%E7%BB%84/"/>
    <id>https://blog.silencew.cn/2019/12/13/db/mysql/04、数据分组/</id>
    <published>2019-12-12T16:00:00.000Z</published>
    <updated>2020-05-18T12:01:30.487Z</updated>
    
    <content type="html"><![CDATA[<h3 id="创建分组"><a href="#创建分组" class="headerlink" title="创建分组"></a>创建分组</h3><p>分组是在SELECT语句中的GROUP BY 子句中建立的。</p><p>例：</p><p><code>SELECT vend_id, COUNT(*) AS num_prods FROM products GROUP BY vend_id;</code></p><img src="/2019/12/13/db/mysql/04、数据分组/1576208076595.png" class="slug"><a id="more"></a><p>GROUP BY</p><ul><li>GROUP BY子句可以包含任意数目的列，这使得能对分组进行嵌套，为数据分组提供更细致的控制。</li><li>如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组商家进行汇总。换句话说，在建立分组时，指定的所有列都一起计算。（所有不能从个别的列取回数据）。</li><li>GROUP BY子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式，不能使用别名</li><li>除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出。</li><li>如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，他们将分为一组。</li><li>GROUP BY子句必须出现在WHERE子句之后，ORDER BY 子句之前。</li></ul><h3 id="过滤分组"><a href="#过滤分组" class="headerlink" title="过滤分组"></a>过滤分组</h3><p>如果想要列出至少有两个订单的所有骨科，这样的数据就必须基于完整的分组而不是个别的行进行过滤。</p><p>可以使用HAVING</p><p><code>SELECT cust_id, COUNT(*) AS orders FROM orders GROUP BY cust_id HAVING COUNT(*) &gt;= 2;</code></p><img src="/2019/12/13/db/mysql/04、数据分组/1576208780736.png" class="slug"><p>HAVING和WHERE的差别，WHERE在数据分组前进行过滤，HAVING在分组后进行过滤。当然，两个也可以在同一条语句中出现。</p><p>列出具有2个（含）以上、价格为10（含）以上的产品的供应商</p><p><code>SELECT vend_id, COUNT(*) AS num_prods FROM products WHERE prod_price &gt;= 10 GROUP BY vend_id HAVING COUNT(*) &gt;= 2;</code></p><img src="/2019/12/13/db/mysql/04、数据分组/1576209189512.png" class="slug"><p>列出具有两个至上的产品的供应商</p><p><code>SELECT vend_id, COUNT(*) AS num_prods FROM products GROUP BY vend_id HAVING COUNT(*) &gt;= 2;</code></p><img src="/2019/12/13/db/mysql/04、数据分组/1576459642113.png" class="slug"><h3 id="分组和排序"><a href="#分组和排序" class="headerlink" title="分组和排序"></a>分组和排序</h3><div class="table-container"><table><thead><tr><th>ORDER BY</th><th>GROUP BY</th></tr></thead><tbody><tr><td>排序产生的输出</td><td>分组行。但输出可能不是分组的顺序</td></tr><tr><td>任意列都可以使用（非选择的列也可以）</td><td>只可能使用选择列或表达式列，而且必须使用每个选择列表达式</td></tr><tr><td>不一定需要</td><td>如果与聚集函数一起使用列（表达式），则必须使用</td></tr></tbody></table></div><p>检索总计订单价格大于等于50的订单的订到号和总计订单价格</p><p><code>SELECT order_num, SUM(quantity*item) AS ordertotal FROM orderitems GROUP BY order_num HAVING SUM(quantity*item_price) &gt;= 50;</code></p><img src="/2019/12/13/db/mysql/04、数据分组/1576468460944.png" class="slug"><p>如果按总计订单价格排序输出</p><p><code>SELECT order_num, SUM(quantity * item_price) AS ordertotal FROM orderitems GROUP BY order_num HAVING SUM(quantity * item_price) &gt;= 50 ORDER BY ordertotal;</code></p><img src="/2019/12/13/db/mysql/04、数据分组/1576491067581.png" class="slug"><p>SELECT子句的顺序</p><div class="table-container"><table><thead><tr><th>子句</th><th>说明</th><th>是否必须使用</th></tr></thead><tbody><tr><td>SELECT</td><td>要返回的列或表达式</td><td>是</td></tr><tr><td>FROM</td><td>从中检索数据的表</td><td>仅在从表选择数据时使用</td></tr><tr><td>GROUP BY</td><td>分组说明</td><td>仅在按组计算聚集时使用</td></tr><tr><td>WHERE</td><td>行级过滤</td><td>否</td></tr><tr><td>HAVING</td><td>组级过滤</td><td>否</td></tr><tr><td>ORDER BY</td><td>输出排序顺序</td><td>否</td></tr><tr><td>LIMIT</td><td>要检索的行数</td><td>否</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;创建分组&quot;&gt;&lt;a href=&quot;#创建分组&quot; class=&quot;headerlink&quot; title=&quot;创建分组&quot;&gt;&lt;/a&gt;创建分组&lt;/h3&gt;&lt;p&gt;分组是在SELECT语句中的GROUP BY 子句中建立的。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SELECT vend_id, COUNT(*) AS num_prods FROM products GROUP BY vend_id;&lt;/code&gt;&lt;/p&gt;
&lt;img src=&quot;/2019/12/13/db/mysql/04、数据分组/1576208076595.png&quot; class=&quot;slug&quot;&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://blog.silencew.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://blog.silencew.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
      <category term="后端" scheme="https://blog.silencew.cn/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="数据库" scheme="https://blog.silencew.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://blog.silencew.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql数据处理函数</title>
    <link href="https://blog.silencew.cn/2019/12/12/db/mysql/03%E3%80%81mysql%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/"/>
    <id>https://blog.silencew.cn/2019/12/12/db/mysql/03、mysql数据处理函数/</id>
    <published>2019-12-11T16:00:00.000Z</published>
    <updated>2020-05-18T12:01:30.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>SQL支持利用函数来处理数据。函数一般是在数据上执行的，它给数据的转换和处理提供了方便。</p><h3 id="文本处理函数"><a href="#文本处理函数" class="headerlink" title="文本处理函数"></a>文本处理函数</h3><div class="table-container"><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>Left()</code></td><td>返回串左边的字符</td></tr><tr><td><code>Length()</code></td><td>返回串的长度</td></tr><tr><td><code>Locate()</code></td><td>找出串的一个子串</td></tr><tr><td><code>Lower()</code></td><td>将串转换为小写</td></tr><tr><td><code>LTrim()</code></td><td>去掉串左边的空格</td></tr><tr><td><code>Right()</code></td><td>返回串右边的字符</td></tr><tr><td><code>RTrim()</code></td><td>去掉串右边的空格</td></tr><tr><td><code>Soundex()</code></td><td>返回串的SOUNDEX值</td></tr><tr><td><code>SubString()</code></td><td>返回子串的字符</td></tr><tr><td><code>Upper()</code></td><td>将串转换为大写</td></tr></tbody></table></div><a id="more"></a><p><code>SELECT vend_name, Upper(vend_name) AS vend_name_upcase FROM vendors ORDER BY vend_name;</code></p><img src="/2019/12/12/db/mysql/03、mysql数据处理函数/1576129039738.png" class="slug"><h3 id="日期和时间处理函数"><a href="#日期和时间处理函数" class="headerlink" title="日期和时间处理函数"></a>日期和时间处理函数</h3><div class="table-container"><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>AddDate()</code></td><td>增加一个日期(天、周等)</td></tr><tr><td><code>AddTime()</code></td><td>增加一个时间(时、分等)</td></tr><tr><td><code>CurDate()</code></td><td>返回当前日期</td></tr><tr><td><code>CurTime()</code></td><td>返回当前时间</td></tr><tr><td><code>Date()</code></td><td>返回日期时间的日期部分</td></tr><tr><td><code>DateDiff()</code></td><td>计算两个日期的差</td></tr><tr><td><code>Date_Add()</code></td><td>高度灵活的日期运算函数</td></tr><tr><td><code>Date_Format()</code></td><td>返回一个格式化的日期或时间串</td></tr><tr><td><code>Day()</code></td><td>返回一个日期的天数部分</td></tr><tr><td><code>DayOfWeek()</code></td><td>对于一个日期，返回对应的星期几</td></tr><tr><td><code>Hour()</code></td><td>返回一个时间的小时部分</td></tr><tr><td><code>Minute()</code></td><td>返回一个时间的分钟部分</td></tr><tr><td><code>Month()</code></td><td>返回一个时间的月份部分</td></tr><tr><td><code>Now()</code></td><td>返回当前日期和时间</td></tr><tr><td><code>Second()</code></td><td>返回一个时间的秒部分</td></tr><tr><td><code>Time()</code></td><td>返回一个日期时间的时间部分</td></tr><tr><td><code>Year()</code></td><td>返回一个日期的年份部分</td></tr></tbody></table></div><p>匹配订单日期在2005-09-01那天：</p><p><code>SELECT cust_id, order_num FROM orders WHERE Date(order_date) = &#39;2005-09-01&#39;;</code></p><p>订单日期在2005年9月份的：</p><p><code>SELECT cust_id, order_num FROM orders WHERE Date(order_date) BETWEEN &#39;2005-09-01&#39; AND &#39;2005-09-30&#39;;</code></p><p>也可以按照下面这种写法，这种写法不必考虑一个月有多少天：</p><p><code>SELECT cust_id, order_num FROM orders WHERE Year(order_date) = 2005 AND Month(order_date) = 9;</code></p><h3 id="数值处理函数"><a href="#数值处理函数" class="headerlink" title="数值处理函数"></a>数值处理函数</h3><div class="table-container"><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>Abs()</code></td><td>返回一个数的绝对值</td></tr><tr><td><code>Cos()</code></td><td>返回一个角度的余弦</td></tr><tr><td><code>Exp()</code></td><td>返回一个数的指数值</td></tr><tr><td><code>Mod()</code></td><td>返回除操作的余数</td></tr><tr><td><code>Pi()</code></td><td>返回圆周率</td></tr><tr><td><code>Rand()</code></td><td>返回一个随机数</td></tr><tr><td><code>Sin()</code></td><td>返回一个角度的正弦</td></tr><tr><td><code>Sqrt()</code></td><td>返回一个数的平方根</td></tr><tr><td><code>Tan()</code></td><td>返回一个角度的正切</td></tr></tbody></table></div><h3 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h3><div class="table-container"><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>AVG()</code></td><td>返回某列的平均值</td></tr><tr><td><code>COUNT()</code></td><td>返回某列的行数</td></tr><tr><td><code>MAX()</code></td><td>返回某列的最大值</td></tr><tr><td><code>MIN()</code></td><td>返回某列的最小值</td></tr><tr><td><code>SUM()</code></td><td>返回某列值之和</td></tr></tbody></table></div><h4 id="AVG-函数"><a href="#AVG-函数" class="headerlink" title="AVG() 函数"></a>AVG() 函数</h4><p>返回products表中所有产品的平均价格：<code>SELECT AVG(prod_price) AS avg_price FROM products;</code></p><p>也可以用来确定特定列或行的平均值。</p><p>返回特定供应商所提供的产品的平均价格：</p><p><code>SELECT AVG(prod_price) AS avg_price FROM products WHERE vend_id = 1003;</code></p><p><strong>AVG()函数只能用于单个列，且忽略列值为NULL的行</strong></p><h4 id="COUNT-函数"><a href="#COUNT-函数" class="headerlink" title="COUNT() 函数"></a>COUNT() 函数</h4><p>返回customers表中客户的总数：</p><p><code>SELETE COUNT(*) AS num_cust FROM customers;</code></p><p>只对具有电子邮件地址的客户计数：</p><p><code>SELECT COUNT(cust_email) AS num_cust FROM customers;</code></p><p><strong>NULL值，如果制定列名，则制定列的值为空的行被COUNT()函数忽略，但如果COUNT()函数中用的是*，则不忽略。</strong></p><h4 id="MAX-函数"><a href="#MAX-函数" class="headerlink" title="MAX() 函数"></a>MAX() 函数</h4><p>返回products表中最贵的物品的价格：</p><p><code>SELECT MAX(prod_price) AS max_price FROM products;</code></p><p><strong>对非数值数据使用MAX()，虽然MAX()一般用来找出最大的数值或时间，但MySQL允许将它用来返回任意列中的最大值，包括返回文本列中的最大值。用于文本数据时，如果数据按相应的列排序，则返回最后一行</strong></p><p><strong>MAX() 函数忽略列值为NULL的行</strong></p><h4 id="MIN-函数"><a href="#MIN-函数" class="headerlink" title="MIN() 函数"></a>MIN() 函数</h4><p>正好与MAX()功能相反</p><p><code>SELECT MIN(prod_price) AS min_price FROM product;</code></p><h4 id="SUM-函数"><a href="#SUM-函数" class="headerlink" title="SUM() 函数"></a>SUM() 函数</h4><p><code>orderitems</code>表包含订单中实际的物品，每个物品有相应的数量(quantity)。检索所订购物品的总数（所有quantity值之和）:</p><p><code>SELECT SUM(quantity) AS items_ordered FROM orderitems WHERE order_num = 20005;</code></p><p>SUM()也可以用来合计计算值。</p><p>合计每项物品的<code>item_price*quantity</code>，得出总的订单金额(where 保证了只统计某个物品订单中的物品)：</p><p><code>SELECT SUM(item_price*quantity) AS total_price FROM orderitems WHERE order_num = 20005;</code></p><h4 id="聚类不同值"><a href="#聚类不同值" class="headerlink" title="聚类不同值"></a>聚类不同值</h4><ul><li>对所有行执行计算，指定ALL参数或者不给参数。(某人是ALL)</li><li>只包含不同的值，指定DISTINCT参数。</li></ul><p><code>SELECT AVG(DISTINCT prod_price) AS avg_price FROM products WHERE vend_id = 1003;</code></p><p><strong>注意：</strong>如果指定列名，则DISTINCT只能用于COUNT()。DISTINCT 不能用于COUNT(*)，因此，不允许使用COUNT(DISTINCT)。类似的，DISTINCT必须使用列名，不能用于计算或表达式。</p><h4 id="组合聚集函数"><a href="#组合聚集函数" class="headerlink" title="组合聚集函数"></a>组合聚集函数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_items, </span><br><span class="line">   <span class="keyword">MIN</span>(prod_price) <span class="keyword">AS</span> price_min, </span><br><span class="line">   <span class="keyword">MAX</span>(prod_price) <span class="keyword">AS</span> price_max, </span><br><span class="line">   <span class="keyword">AVG</span>(prod_price) <span class="keyword">AS</span> price_avg </span><br><span class="line"><span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure><img src="/2019/12/12/db/mysql/03、mysql数据处理函数/1576139707847.png" class="slug">]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h2&gt;&lt;p&gt;SQL支持利用函数来处理数据。函数一般是在数据上执行的，它给数据的转换和处理提供了方便。&lt;/p&gt;&lt;h3 id=&quot;文本处理函数&quot;&gt;&lt;a href=&quot;#文本处理函数&quot; class=&quot;headerlink&quot; title=&quot;文本处理函数&quot;&gt;&lt;/a&gt;文本处理函数&lt;/h3&gt;&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Left()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回串左边的字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Length()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回串的长度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Locate()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;找出串的一个子串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Lower()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将串转换为小写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;LTrim()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;去掉串左边的空格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Right()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回串右边的字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;RTrim()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;去掉串右边的空格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Soundex()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回串的SOUNDEX值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SubString()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回子串的字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Upper()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将串转换为大写&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://blog.silencew.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://blog.silencew.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
      <category term="后端" scheme="https://blog.silencew.cn/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="数据库" scheme="https://blog.silencew.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://blog.silencew.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql正则字符</title>
    <link href="https://blog.silencew.cn/2019/12/12/db/mysql/01%E3%80%81mysql%E6%AD%A3%E5%88%99/"/>
    <id>https://blog.silencew.cn/2019/12/12/db/mysql/01、mysql正则/</id>
    <published>2019-12-11T16:00:00.000Z</published>
    <updated>2020-05-18T12:01:30.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><div class="table-container"><table><thead><tr><th style="text-align:left">类</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left">[:alnum:]</td><td>任意字母和数字(同[a-zA-Z0-9])</td></tr><tr><td style="text-align:left">[:alpha:]</td><td>任意字符(同[a-zA-Z])</td></tr><tr><td style="text-align:left">[:blank:]</td><td>空格和制表(同[\t])</td></tr><tr><td style="text-align:left">[:cntrl:]</td><td>ASCII控制字符(ASCII 0到32 和127)</td></tr><tr><td style="text-align:left">[:digit:]</td><td>任意数字(同[0-9])</td></tr><tr><td style="text-align:left">[:graph:]</td><td>与[:print:]相同，但不包括空格</td></tr><tr><td style="text-align:left">[:lower:]</td><td>任意小写字母(同[a-z])</td></tr><tr><td style="text-align:left">[:print:]</td><td>任意可打印字符</td></tr><tr><td style="text-align:left">[:punct:]</td><td>既不在[:alnum:]又不在[:cntrl:]中的任意字符</td></tr><tr><td style="text-align:left">[:space:]</td><td>包括空格在内的任意空白字符(同[\f\n\r\t\v])</td></tr><tr><td style="text-align:left">[:upper:]</td><td>任意大写字母(同[A-Z])</td></tr><tr><td style="text-align:left">[:xdigit:]</td><td>任意十六进制数字</td></tr></tbody></table></div><a id="more"></a><h2 id="空白元字符"><a href="#空白元字符" class="headerlink" title="空白元字符"></a>空白元字符</h2><div class="table-container"><table><thead><tr><th style="text-align:left">元字符</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left">\f</td><td>换页</td></tr><tr><td style="text-align:left">\n</td><td>换行</td></tr><tr><td style="text-align:left">\r</td><td>回车</td></tr><tr><td style="text-align:left">\t</td><td>制表</td></tr><tr><td style="text-align:left">\v</td><td>纵向制表</td></tr></tbody></table></div><h2 id="重复元字符"><a href="#重复元字符" class="headerlink" title="重复元字符"></a>重复元字符</h2><div class="table-container"><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>0个或多个匹配</td></tr><tr><td>+</td><td>1个或多个匹配(等于{1, })</td></tr><tr><td>?</td><td>0个或1个匹配(等于{0})</td></tr><tr><td>{n}</td><td>指定数目的匹配</td></tr><tr><td>{n, }</td><td>不少于指定数目的匹配</td></tr><tr><td>{n, m}</td><td>匹配数目的范围(m不超过255)</td></tr></tbody></table></div><h2 id="定位元字符"><a href="#定位元字符" class="headerlink" title="定位元字符"></a>定位元字符</h2><div class="table-container"><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>文本的开始</td></tr><tr><td>$</td><td>文本的结束</td></tr><tr><td>[[:&lt;:]]</td><td>词的开始</td></tr><tr><td>[[:&gt;:]]</td><td>词的结束</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;字符类&quot;&gt;&lt;a href=&quot;#字符类&quot; class=&quot;headerlink&quot; title=&quot;字符类&quot;&gt;&lt;/a&gt;字符类&lt;/h2&gt;&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;类&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;[:alnum:]&lt;/td&gt;
&lt;td&gt;任意字母和数字(同[a-zA-Z0-9])&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;[:alpha:]&lt;/td&gt;
&lt;td&gt;任意字符(同[a-zA-Z])&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;[:blank:]&lt;/td&gt;
&lt;td&gt;空格和制表(同[\t])&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;[:cntrl:]&lt;/td&gt;
&lt;td&gt;ASCII控制字符(ASCII 0到32 和127)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;[:digit:]&lt;/td&gt;
&lt;td&gt;任意数字(同[0-9])&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;[:graph:]&lt;/td&gt;
&lt;td&gt;与[:print:]相同，但不包括空格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;[:lower:]&lt;/td&gt;
&lt;td&gt;任意小写字母(同[a-z])&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;[:print:]&lt;/td&gt;
&lt;td&gt;任意可打印字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;[:punct:]&lt;/td&gt;
&lt;td&gt;既不在[:alnum:]又不在[:cntrl:]中的任意字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;[:space:]&lt;/td&gt;
&lt;td&gt;包括空格在内的任意空白字符(同[\f\n\r\t\v])&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;[:upper:]&lt;/td&gt;
&lt;td&gt;任意大写字母(同[A-Z])&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;[:xdigit:]&lt;/td&gt;
&lt;td&gt;任意十六进制数字&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://blog.silencew.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://blog.silencew.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
      <category term="后端" scheme="https://blog.silencew.cn/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="数据库" scheme="https://blog.silencew.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://blog.silencew.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql计算字段</title>
    <link href="https://blog.silencew.cn/2019/12/12/db/mysql/02%E3%80%81mysql%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5/"/>
    <id>https://blog.silencew.cn/2019/12/12/db/mysql/02、mysql计算字段/</id>
    <published>2019-12-11T16:00:00.000Z</published>
    <updated>2020-05-18T12:01:30.484Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a>计算字段</h2><p>存储在数据库表中的数据一般不是应用程序所需要的格式。</p><ul><li>如果想在一个字段中既显示公司名，又显示公司的地址，但是这两个信息一般包含在不同的表列中。</li><li>城市、州和邮政编码存储在不同的列中，但邮件标签打印程序却需要把它们作为一个恰当格式的字段检索出来。</li><li>列数据是大小写混合的，但报表程序需要把所有数据按大写表示出来</li><li>物品订单表存储物品的价格和数量，但不需要存储每个物品的总价格（用价格乘以数量即可）。</li><li>根据表数据进行总数，平均数计算或其他计算</li></ul><a id="more"></a><h3 id="1-拼接字段"><a href="#1-拼接字段" class="headerlink" title="1. 拼接字段"></a>1. 拼接字段</h3><p>举例：vendors表中包含供应商名和位置信息。假如要生成一个供应商报表，需要在供应商的名字中按照name(location)这样的格式列出供应商的位置。</p><p>此报表需要单个值，而表中数据存储在两个列<code>vend_name</code>和<code>vend_country</code>中。此外，需要用括号将<code>vend_country</code>括起来。</p><h4 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h4><p>可以使用<code>Contcat()</code>函数来拼接两个列</p><p><code>SELECT Concat(vend_name, &#39; (&#39;, vend_country, &#39;)&#39;) FROM vendors ORDER BY vend_name;</code></p><p>同时，我们需要删除数据右侧多余的空格，可以使用<code>RTrim()</code>来完成</p><p><code>SELECT Concat(RTrim(vend_name), &#39; (&#39;, RTrim(vend_country), &#39;)&#39;) FROM vendors ORDER BY vend_name;</code></p><p>去除空格还可以用<code>LTrim()</code>去掉左边的空格，<code>Trim()</code>去掉右边的空格</p><h4 id="使用别名"><a href="#使用别名" class="headerlink" title="使用别名"></a>使用别名</h4><p><code>SELECT Concat(RTrim(vend_name), &#39; (&#39;, RTrim(vend_country), &#39;)&#39;) AS vend_title FROM vendors ORDER BY vend_name;</code></p><h3 id="2-执行算术计算"><a href="#2-执行算术计算" class="headerlink" title="2. 执行算术计算"></a>2. 执行算术计算</h3><p>orders表包含收到的所有订单，orderitems表包含每个订到的各项物品。下面的SQL语句检索订单号20005中的所有物品</p><p><code>SELECT prod_id, quantity, item_price FROM orderitems WHERE order_num = 20005;</code></p><img src="/2019/12/12/db/mysql/02、mysql计算字段/1576122299642.png" class="slug"><p>item_prict 列包好订单中每项物品的单价，如下可以汇总物品的价格</p><p><code>SELECT prod_id, quantity, item_price, quantity*item_price AS expanded_price FROM orderitems WHERE order_num = 20005;</code> </p><h4 id="MySQL算术操作符"><a href="#MySQL算术操作符" class="headerlink" title="MySQL算术操作符"></a>MySQL算术操作符</h4><div class="table-container"><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td>加</td></tr><tr><td>-</td><td>减</td></tr><tr><td>*</td><td>乘</td></tr><tr><td>/</td><td>除</td></tr></tbody></table></div><h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><p><code>SELECT Now();</code> 会利用<code>Now()</code>函数返回当前日期和时间</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;计算字段&quot;&gt;&lt;a href=&quot;#计算字段&quot; class=&quot;headerlink&quot; title=&quot;计算字段&quot;&gt;&lt;/a&gt;计算字段&lt;/h2&gt;&lt;p&gt;存储在数据库表中的数据一般不是应用程序所需要的格式。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;如果想在一个字段中既显示公司名，又显示公司的地址，但是这两个信息一般包含在不同的表列中。&lt;/li&gt;
&lt;li&gt;城市、州和邮政编码存储在不同的列中，但邮件标签打印程序却需要把它们作为一个恰当格式的字段检索出来。&lt;/li&gt;
&lt;li&gt;列数据是大小写混合的，但报表程序需要把所有数据按大写表示出来&lt;/li&gt;
&lt;li&gt;物品订单表存储物品的价格和数量，但不需要存储每个物品的总价格（用价格乘以数量即可）。&lt;/li&gt;
&lt;li&gt;根据表数据进行总数，平均数计算或其他计算&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://blog.silencew.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://blog.silencew.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
      <category term="后端" scheme="https://blog.silencew.cn/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="数据库" scheme="https://blog.silencew.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://blog.silencew.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>树</title>
    <link href="https://blog.silencew.cn/2019/11/20/algorithm%5B%E7%AE%97%E6%B3%95%5D/5.%E6%A0%91/"/>
    <id>https://blog.silencew.cn/2019/11/20/algorithm[算法]/5.树/</id>
    <published>2019-11-19T16:00:00.000Z</published>
    <updated>2019-11-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>树（tree）是n（n&lt;=0）个节点的有限集。当n=0时，成为空树。在任意一个非空树中，有如下特点：</p><ul><li>有且仅有一个特定的成为根的节点。</li><li>当n&gt;1时，其余节点可分为m（m&gt;0）个互不相交的有限集，每一个集合本身又是一个树，并称为根的子树</li></ul><a id="more"></a><img src="/2019/11/20/algorithm[算法]/5.树/树01.png" class="slug"><img src="/2019/11/20/algorithm[算法]/5.树/树02.png" class="slug"><p>树的最大层级数，被称为树的高度或深度，上面这个数的高度是4</p><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>二叉树（binary tree）是树的一种特殊形式。这种树的每个节点最多有两个孩子节点。</p><img src="/2019/11/20/algorithm[算法]/5.树/二叉树01.png" class="slug"><p>二叉树有两种特殊的形式，一个叫做满二叉树，另一个叫完全二叉树。</p><ul><li><p>满二叉树</p><p>一个二叉树的所有非叶子节点都存在左右孩子，并且所有的叶子节点都在同一层级上；简单来说，满二叉树的每一个分支都是满的</p><img src="/2019/11/20/algorithm[算法]/5.树/满二叉树.png" class="slug"></li><li><p>完全二叉树</p><p>对一个有n个节点的二叉树，按层级顺序编号，则所有的节点的编号为从1到n。如果这个树所有节点和同样深度的满二叉树的编号为从1到n的节点位置相同，则这个二叉树为完全二叉树。</p><img src="/2019/11/20/algorithm[算法]/5.树/完全二叉树.png" class="slug"><p>上图中，二叉树编号从1到12的12个节点，和前面满二叉树从1到12的节点位置完全对应，因此这个树是完全二叉树。</p></li></ul><p>完全二叉树的条件没有满二叉树那么苛刻：满二叉树要求所有分支都是满的；而完全二叉树只需保证最后一个节点之前的节点都齐全即可。</p><p>存储结构：</p><ul><li><p>链式存储结构</p><img src="/2019/11/20/algorithm[算法]/5.树/链式二叉树.png" class="slug"><p>链式存储是二叉树最直观的存储方式。</p><p>一个节点最多可以指向左右两个孩子节点，所以二叉树的每一个节点包含3部分</p><ul><li>存储数据的data变量</li><li>指向左孩子的left指针</li><li>指向右孩子的right指针</li></ul></li><li><p>数组</p><img src="/2019/11/20/algorithm[算法]/5.树/数组二叉树.png" class="slug"><p>使用数组存储时，会按照层级顺序把二叉树的节点放到数组中对应的位置。如果某一个节点的左孩子或者右孩子空缺，则数组的相应位置也空出来。</p><p>这样设计可以更方便的在数组中定位二叉树的孩子节点和父节点。</p><p>假设一个父节点的下标是parent，那么它的左孩子节点下标就是<code>2 × parent + 1</code>，右孩子节点的下标就是<code>2 × parent + 2</code></p><p>反过来，一个左孩子节点下标是leftChild，那么它的父节点的下标就是<code>(leftChild - 1) / 2</code></p></li></ul><p>对于一个稀疏的二叉树来说，用数组表示法是非常浪费空间的。</p><h5 id="二叉树的应用"><a href="#二叉树的应用" class="headerlink" title="二叉树的应用"></a>二叉树的应用</h5><h6 id="1-查找"><a href="#1-查找" class="headerlink" title="1. 查找"></a>1. 查找</h6><p>二叉查找树</p><ul><li>如果左子树不为空，则左子树上所有节点的值均小于根节点的值</li><li>如果右子树不为空，则右子树上所有节点的值均大于根节点的值</li><li>左右子树也都是二叉查找树</li></ul><img src="/2019/11/20/algorithm[算法]/5.树/二叉查找树01.png" class="slug"><p>例如查找值为4的节点</p><ul><li><p>访问根节点6，发现4 &lt; 6</p><img src="/2019/11/20/algorithm[算法]/5.树/二叉查找树02.png" class="slug"></li><li><p>访问节点6的左孩子节点3，发现4 &gt; 3</p><img src="/2019/11/20/algorithm[算法]/5.树/二叉查找树03.png" class="slug"></li><li><p>访问节点3的右孩子节点4，发现4 = 4，正是要找的节点</p><img src="/2019/11/20/algorithm[算法]/5.树/二叉查找树04.png" class="slug"></li></ul><p>对于一个节点分布相对均衡的二叉查找树来说，如果节点总数是n，那么搜索节点的时间复杂度就是<code>O(logn)</code>，和树的深度是一样的。</p><h6 id="2-维持相对顺序"><a href="#2-维持相对顺序" class="headerlink" title="2. 维持相对顺序"></a>2. 维持相对顺序</h6><p>仍然要从二叉查找树说起，二叉查找树要求左子树小于父节点，右子树大于父节点，正是这样保证了二叉树的有序性。</p><p>因此二叉查找树又叫二叉排序树</p><p>新插入的节点，同样要遵循二叉排序树的原则，例如插入新元素5，由于5 &lt; 6, 5 &gt; 3, 5 &gt; 4，所以最终为插入节点4的右孩子的位置</p><img src="/2019/11/20/algorithm[算法]/5.树/二叉查找树05.png" class="slug"><p>这样却隐藏了一个致命的问题，在二叉查找树中依次插入9、8、7、6、5、4会出现下面这种情况</p><img src="/2019/11/20/algorithm[算法]/5.树/二叉查找树06.png" class="slug"><p>这就涉及到了二叉树的自平衡，后面会说到</p><h5 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h5><p>分为4种：前序遍历，中序遍历，后序遍历，层序遍历</p><p>从更宏观的角度来看，二叉树的遍历归结为两大类：</p><ul><li>深度优先遍历（前序遍历，中序遍历，后序遍历）</li><li>广度优先遍历（层序遍历）</li></ul><h6 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h6><ul><li><p>前序遍历</p><p>输出顺序是根节点，左子树，右子树</p><img src="/2019/11/20/algorithm[算法]/5.树/前序遍历.png" class="slug"></li><li><p>中序遍历</p><p>输出顺序是左子树，根节点，右子树</p><img src="/2019/11/20/algorithm[算法]/5.树/中序遍历.png" class="slug"></li><li><p>后序遍历</p><p>输出顺序是左子树，右子树，根节点</p></li></ul><p>递归的方式</p><p>非递归方式（栈）</p><ol><li><p>首先遍历二叉树的根节点，放入栈中。</p><img src="/2019/11/20/algorithm[算法]/5.树/二叉树非递归遍历01.png" class="slug"></li><li><p>遍历根节点1的左孩子节点2，放入栈中。</p><img src="/2019/11/20/algorithm[算法]/5.树/二叉树非递归遍历02.png" class="slug"></li><li><p>遍历节点2的左孩子节点4，放入栈中。</p><img src="/2019/11/20/algorithm[算法]/5.树/二叉树非递归遍历03.png" class="slug"></li><li><p>节点4既没有左孩子，也没有右孩子，我们需要回溯到上一个节点2。</p><p>因为栈已经存储了刚才遍历的路径。让旧的栈顶元素4出栈，就可以重新访问节点2，得到节点2的右孩子节点5.</p><p>此时节点2已经没有利用价值了，节点2出栈，节点5入栈。</p><img src="/2019/11/20/algorithm[算法]/5.树/二叉树非递归遍历04.png" class="slug"></li><li><p>节点5既没有左孩子，也没有右孩子，我们需要再次回溯，一直回溯到节点1，所以让节点5出栈，根节点1的右孩子是节点3，节点1出栈，节点3入栈。</p><img src="/2019/11/20/algorithm[算法]/5.树/二叉树非递归遍历05.png" class="slug"></li><li><p>节点3的右孩子是节点6，节点3出栈，节点6入栈</p></li><li><p>节点6既没有左孩子，也没有右孩子，所以节点6出栈。此时栈为空，遍历结束。</p><img src="/2019/11/20/algorithm[算法]/5.树/二叉树非递归遍历07.png" class="slug"></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">helloword</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建二叉树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputList 输入序列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">createBinaryTree</span><span class="params">(LinkedList&lt;Integer&gt; inputList)</span> </span>&#123;</span><br><span class="line">        TreeNode node = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (inputList == <span class="keyword">null</span> || inputList.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Integer data = inputList.removeFirst();</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node = <span class="keyword">new</span> TreeNode(data);</span><br><span class="line">            node.leftChild = createBinaryTree(inputList);</span><br><span class="line">            node.rightChild = createBinaryTree(inputList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉树的前序遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 二叉树节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderTraveral</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(node.data);</span><br><span class="line">        preOrderTraveral(node.leftChild);</span><br><span class="line">        preOrderTraveral(node.rightChild);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉树的中序遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 二叉树节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderTraveral</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrderTraveral(node.leftChild);</span><br><span class="line">        System.out.println(node.data);</span><br><span class="line">        inOrderTraveral(node.rightChild);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉树的后序遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 二叉树节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrderTraveral</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postOrderTraveral(node.leftChild);</span><br><span class="line">        postOrderTraveral(node.rightChild);</span><br><span class="line">        System.out.println(node.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉树节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        TreeNode leftChild;</span><br><span class="line">        TreeNode rightChild;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="keyword">int</span> data) &#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉树非递归前序遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 二叉树根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderTraveralWithStack</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode treeNode = root;</span><br><span class="line">        <span class="keyword">while</span>(treeNode != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 迭代访问节点的左孩子，并入栈</span></span><br><span class="line">            <span class="keyword">while</span> (treeNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(treeNode.data);</span><br><span class="line">                stack.push(treeNode);</span><br><span class="line">                treeNode = treeNode.leftChild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果节点没有左孩子，则弹出栈顶节点，访问节点右孩子</span></span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                treeNode = stack.pop();</span><br><span class="line">                treeNode = treeNode.rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; inputList = <span class="keyword">new</span> LinkedList&lt;Integer&gt;(Arrays.asList(<span class="keyword">new</span> Integer[]&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">10</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">8</span>, <span class="keyword">null</span>, <span class="number">4</span>&#125;));</span><br><span class="line">        TreeNode treeNode = createBinaryTree(inputList);</span><br><span class="line">        System.out.println(<span class="string">"前序遍历: "</span>);</span><br><span class="line">        preOrderTraveral(treeNode);</span><br><span class="line">        System.out.println(<span class="string">"无递归实现前序遍历: "</span>);</span><br><span class="line">        preOrderTraveralWithStack(treeNode);</span><br><span class="line">        System.out.println(<span class="string">"中序遍历: "</span>);</span><br><span class="line">        inOrderTraveral(treeNode);</span><br><span class="line">        System.out.println(<span class="string">"后序遍历: "</span>);</span><br><span class="line">        postOrderTraveral(treeNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h6><img src="/2019/11/20/algorithm[算法]/5.树/二叉树广度优先遍历.png" class="slug"><ol><li><p>根节点1进入队列</p><img src="/2019/11/20/algorithm[算法]/5.树/二叉树广度优先遍历01.png" class="slug"></li><li><p>节点1出队，输出节点1，并得到节点1的左孩子节点2、右孩子节点3.让节点2和节点3入队。</p><img src="/2019/11/20/algorithm[算法]/5.树/二叉树广度优先遍历02.png" class="slug"></li><li><p>节点2出队，输出节点2，并得到节点2的左孩子4、右孩子节点5。让节点4和节点5入队。</p><img src="/2019/11/20/algorithm[算法]/5.树/二叉树广度优先遍历03.png" class="slug"></li><li><p>节点3出队，输出节点3，并得到节点三的右孩子节点6。让节点6入队</p><img src="/2019/11/20/algorithm[算法]/5.树/二叉树广度优先遍历04.png" class="slug"></li><li><p>节点4出队，输出节点4，由于节点4没有孩子节点，所以没有新节点入队</p><img src="/2019/11/20/algorithm[算法]/5.树/二叉树广度优先遍历05.png" class="slug"></li><li><p>节点5出队，输出节点5，由于节点5同样没有孩子节点，所以没有新节点入队。</p><img src="/2019/11/20/algorithm[算法]/5.树/二叉树广度优先遍历06.png" class="slug"></li><li><p>节点6出队，输出节点6，节点6没有孩子节点，没有新节点入队</p><img src="/2019/11/20/algorithm[算法]/5.树/二叉树广度优先遍历07.png" class="slug"></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 二叉树层序遍历</span></span><br><span class="line"><span class="comment">* @param root 二叉树根节点</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">levelOrderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode node = queue.poll();</span><br><span class="line">        System.out.println(node.data);</span><br><span class="line">        <span class="keyword">if</span> (node.leftChild != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.offer(node.leftChild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.rightChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node.rightChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h4><p>二叉堆本质上是一种完全二叉树，分为两个类型</p><ul><li><p>最大堆</p><p>最大堆的任何一个父节点的值，都大于或等于它左、右孩子节点的值。</p><img src="/2019/11/20/algorithm[算法]/5.树/最大堆.png" class="slug"></li><li><p>最小堆</p><p>最小堆的任何一个父节点的值，都小于或等于它左、右孩子节点的值。</p><img src="/2019/11/20/algorithm[算法]/5.树/最小堆.png" class="slug"></li></ul><p>二叉树的根节点叫做堆顶。</p><p>最大堆和最小堆的特点决定了：最大堆的堆顶是整个堆中的最大元素；最小堆的堆顶是整个堆中的最小元素。</p><h5 id="二叉堆的自我调整"><a href="#二叉堆的自我调整" class="headerlink" title="二叉堆的自我调整"></a>二叉堆的自我调整</h5><p>堆的插入和删除操作时间复杂度是<code>O(logn)</code></p><p>节点的上浮和下沉时间复杂度是<code>O(logn)</code></p><p>构建的时间复杂度是<code>O(n)</code></p><ol><li><p>插入节点</p><p>当二叉堆插入节点时，插入位置是完全二叉树的最后一个位置。例如插入一个新节点，值是0</p><img src="/2019/11/20/algorithm[算法]/5.树/二叉堆插入节点01.png" class="slug"><p>这时，新节点的父节点5比0大，显然不符合最小堆的性质，于是让新节点“上浮”，和父节点交换位置</p><img src="/2019/11/20/algorithm[算法]/5.树/二叉堆插入节点02.png" class="slug"><p>继续用节点0和父节点3作比较，因为0小于3，则让新节点继续上浮</p><img src="/2019/11/20/algorithm[算法]/5.树/二叉堆插入节点03.png" class="slug"><p>最终新节点0“上浮”到了堆顶位置</p><img src="/2019/11/20/algorithm[算法]/5.树/二叉堆插入节点04.png" class="slug"></li><li><p>删除节点</p><p>二叉堆删除节点的过程和插入节点的过程正好相反，所删除的是处于堆顶的节点1</p><img src="/2019/11/20/algorithm[算法]/5.树/二叉堆删除节点01.png" class="slug"><p>这时，为了继续维持完全二叉树的结构，我们把堆的最后一个节点10临时补到原本的堆顶位置。</p><img src="/2019/11/20/algorithm[算法]/5.树/二叉堆删除节点02.png" class="slug"><p>接下来，让暂处栈顶位置的节点10和它的左、右孩子节点中最小的一个，显然是节点2，那么让节点10“下沉”。</p><img src="/2019/11/20/algorithm[算法]/5.树/二叉堆删除节点03.png" class="slug"><p>继续让节点10和它的左右孩子作比较，左右孩子中最小的节点7，由于10大于7，让节点10继续“下沉”</p><img src="/2019/11/20/algorithm[算法]/5.树/二叉堆删除节点04.png" class="slug"><p>这样，二叉堆重新得到了调整</p></li><li><p>构建二叉堆</p><p>构建二叉堆就是把一个完全无序的二叉树调整为二叉堆，本质就是让所有的非叶子节点依次下沉。</p><img src="/2019/11/20/algorithm[算法]/5.树/构建二叉堆01.png" class="slug"><p>首先，从最后一个非叶子节点开始，也就是从节点10开始。如果节点10大于它左、右孩子节点中最小的一个，则节点10下沉</p><img src="/2019/11/20/algorithm[算法]/5.树/构建二叉堆02.png" class="slug"><p>接下来轮到节点3，如果节点3,大于它左、右孩子节点中最小的一个，则节点3下沉</p><img src="/2019/11/20/algorithm[算法]/5.树/构建二叉堆03.png" class="slug"><p>然后轮到节点1，如果节点1大于它左、右孩子节点中最小的一个，则节点1下沉。</p><p>接下来轮到节点7，如果节点7大于它左、右孩子节点中最小的一个，则节点7下沉</p><img src="/2019/11/20/algorithm[算法]/5.树/构建二叉堆04.png" class="slug"><p>节点7继续比较，继续下沉</p><img src="/2019/11/20/algorithm[算法]/5.树/构建二叉堆05.png" class="slug"><p>经过上述的几轮比较和下沉，最终每一节点都小于它的左右孩子节点，一个无序的完全二叉树就被构建成了一个最小堆。</p></li></ol><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>二叉堆虽然是一个完全二叉树，但它的存储方式并不是链式的，而是顺序存储。二叉堆的所有节点都存储在数组中</p><img src="/2019/11/20/algorithm[算法]/5.树/二叉堆的存储.png" class="slug"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * “上浮”调整</span></span><br><span class="line"><span class="comment">     * @param array 待调整的堆</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> childIndex = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> parentIndex = (childIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// temp 保存插入的叶子节点值，用于最后的赋值</span></span><br><span class="line">        <span class="keyword">int</span> temp = array[childIndex];</span><br><span class="line">        <span class="keyword">while</span> (childIndex &gt; <span class="number">0</span> &amp;&amp; temp &lt; array[parentIndex]) &#123;</span><br><span class="line">            <span class="comment">// 无须真正交换，单向赋值即可</span></span><br><span class="line">            array[childIndex] = array[parentIndex];</span><br><span class="line">            childIndex = parentIndex;</span><br><span class="line">            parentIndex = (parentIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        array[childIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * “下沉”调整</span></span><br><span class="line"><span class="comment">     * @param array 待调整的堆</span></span><br><span class="line"><span class="comment">     * @param parentIndex 要“下沉”的父节点</span></span><br><span class="line"><span class="comment">     * @param length 堆的有效大小</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> parentIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// temp 保存父节点值，用于最后的赋值</span></span><br><span class="line">        <span class="keyword">int</span> temp = array[parentIndex];</span><br><span class="line">        <span class="keyword">int</span> childIndex = <span class="number">2</span> * parentIndex + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (childIndex &lt; length) &#123;</span><br><span class="line">            <span class="comment">// 如果有右孩子，且右孩子小于左孩子的值，则定位到右孩子</span></span><br><span class="line">            <span class="keyword">if</span> (childIndex + <span class="number">1</span> &lt; length &amp;&amp; array[childIndex + <span class="number">1</span>] &lt; array[childIndex]) &#123;</span><br><span class="line">                childIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果父节点小于任何一个孩子的值，则直接跳出</span></span><br><span class="line">            <span class="keyword">if</span> (temp &lt;= array[childIndex]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 无需真正的交换，单向赋值即可</span></span><br><span class="line">            array[parentIndex] = array[childIndex];</span><br><span class="line">            parentIndex = childIndex;</span><br><span class="line">            childIndex = <span class="number">2</span> * childIndex + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        array[parentIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 构建堆</span></span><br><span class="line"><span class="comment">     * @param array 待调整的堆</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从最后一个非叶子节点开始，依次下沉调整</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (array.length - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            downAdjust(array, i, array.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        upAdjust(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        buildHeap(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><p>优先队列不再遵循先入先出的原则，而是分为两种情况</p><ul><li>最大优先队列，无论入队顺序如何，都是当前最大的元素优先出队</li><li>最小优先队列，无论入队顺序如何，都是当前最小的元素优先出队</li></ul><p>对列的入队和出队与二叉堆的插入和删除一致，所以时间复杂度也是<code>O(logn)</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;树（tree）是n（n&amp;lt;=0）个节点的有限集。当n=0时，成为空树。在任意一个非空树中，有如下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有且仅有一个特定的成为根的节点。&lt;/li&gt;
&lt;li&gt;当n&amp;gt;1时，其余节点可分为m（m&amp;gt;0）个互不相交的有限集，每一个集合本身又是一个树，并称为根的子树&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://blog.silencew.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://blog.silencew.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>复杂度</title>
    <link href="https://blog.silencew.cn/2019/11/19/algorithm%5B%E7%AE%97%E6%B3%95%5D/3.%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>https://blog.silencew.cn/2019/11/19/algorithm[算法]/3.复杂度/</id>
    <published>2019-11-18T16:00:00.000Z</published>
    <updated>2019-11-18T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>简单来说，时间复杂度是执行算法的时间成本，空间复杂度是执行算法的空间成本。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>定义：若存在函数<code>f(n)</code>，使得当n趋近于无穷大时，<code>T(n)/f(n)</code>的极限值为不等于零的常数，则称<code>f(n)</code>是<code>T(n)</code>的同数量级函数。记作<code>T(n)=O(f(n))</code>，<code>O</code>为算法的渐进时间复杂度，简称为时间复杂度。</p> <a id="more"></a><p>注意：</p><ul><li>如果运行时间是常数量级，则用常数1表示。</li><li>只保留时间函数中的最高阶项。</li><li>如果最高阶项存在，则省去最高阶项前面的系数。</li></ul><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。</p><p>公式记作：<code>S(n)=O(f(n))</code>，其中n为问题的规模，f(n)为算法所占存储空间的函数。</p><h5 id="常见的空间复杂度"><a href="#常见的空间复杂度" class="headerlink" title="常见的空间复杂度"></a>常见的空间复杂度</h5><ol><li><p>常量空间</p><p>当算法的存储空间大小固定，和输入规模完全没有直接的关系时，空间复杂度记作O(1)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">viod <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> var = <span class="number">3</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>线性空间</p><p>当算法分配的空间是一个线性的集合（如数组），并且集合大小和输入规模n成正比时，空间复杂度记作O(n)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] <span class="built_in">array</span> = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二维空间</p><p>当算法分配的空间是一个二维数组集合，并且集合的长度和宽度都与输入规模n成正比时，空间复杂度记作O(n^2)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>递归空间</p><p>计算机在执行这类程序时，会专门分配一块内存，用来存储“方法调用栈”。</p><p>“方法调用栈”包括进栈和出栈两个行为。</p><p>当进入一个新方法时，执行入栈操作，把调用的方法和参数信息压入栈中。</p><p>当方法返回时，执行出栈操作，把调用的方法和参数信息从栈中弹出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun4</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">fun4(n<span class="number">-1</span>);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果初始值传入的参数值为n=5，下图为最终所需要的内存空间，递归结束，全部元素一一出栈。</p><img src="/2019/11/19/algorithm[算法]/3.复杂度/递归空间.png" class="slug"></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单来说，时间复杂度是执行算法的时间成本，空间复杂度是执行算法的空间成本。&lt;/p&gt;
&lt;h4 id=&quot;时间复杂度&quot;&gt;&lt;a href=&quot;#时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;时间复杂度&quot;&gt;&lt;/a&gt;时间复杂度&lt;/h4&gt;&lt;p&gt;定义：若存在函数&lt;code&gt;f(n)&lt;/code&gt;，使得当n趋近于无穷大时，&lt;code&gt;T(n)/f(n)&lt;/code&gt;的极限值为不等于零的常数，则称&lt;code&gt;f(n)&lt;/code&gt;是&lt;code&gt;T(n)&lt;/code&gt;的同数量级函数。记作&lt;code&gt;T(n)=O(f(n))&lt;/code&gt;，&lt;code&gt;O&lt;/code&gt;为算法的渐进时间复杂度，简称为时间复杂度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://blog.silencew.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://blog.silencew.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://blog.silencew.cn/2019/11/19/algorithm%5B%E7%AE%97%E6%B3%95%5D/4.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://blog.silencew.cn/2019/11/19/algorithm[算法]/4.数据结构/</id>
    <published>2019-11-18T16:00:00.000Z</published>
    <updated>2019-11-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-数组和链表"><a href="#1-数组和链表" class="headerlink" title="1. 数组和链表"></a>1. 数组和链表</h3><h4 id="1-1-数组"><a href="#1-1-数组" class="headerlink" title="1.1 数组"></a>1.1 数组</h4><p>数组是有限个相同类型的变量所组成的有序集合，数组中的每一个变量被称为元素。</p><p>数组中的每一个元素，都存储在内存单元中，并且元素之间紧密排列，既不能打乱元素的存储顺序，也不能跳过某个存储单元进行存储。</p><a id="more"></a><h5 id="1-1-1-数组的基本操作"><a href="#1-1-1-数组的基本操作" class="headerlink" title="1.1.1 数组的基本操作"></a>1.1.1 数组的基本操作</h5><p>更新和读取的时间复杂度是<code>O(1)</code></p><p>插入和删除的时间复杂度是<code>O(n)</code></p><p>还有一种删除操作：如果数组无序，把最后一个元素复制到要删除元素的位置，然后删除最后一个元素。这样时间复杂度为<code>O(1)</code></p><ol><li><p>读取元素</p><p>由于数组在内存中顺序存储，所以只要给出一个数组下标，就可以读取到对应的数组元素。</p><p>根据下标读取元素的方式叫做随机读取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">// 输出数组中下标为3的元素</span></span><br><span class="line">System.out.println(array[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure></li><li><p>更新元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>&#125;;</span><br><span class="line">array[<span class="number">5</span>] = <span class="number">10</span>;</span><br><span class="line">System.out.println(array[<span class="number">5</span>]);</span><br></pre></td></tr></table></figure></li><li><p>插入元素</p><ul><li>尾部插入</li><li>中间插入</li><li>超范围插入（需要创建一个新数组）</li></ul></li><li><p>删除元素</p><p>数组的删除操作和插入操作的过程相反，如果删除的元素位于数组中间，其后的元素都需要向前挪动一位。</p></li></ol><h5 id="1-1-2-数组的优势和劣势"><a href="#1-1-2-数组的优势和劣势" class="headerlink" title="1.1.2 数组的优势和劣势"></a>1.1.2 数组的优势和劣势</h5><p>数组具有非常高效的随机访问能力，只要给出下标，就可以用常量时间找到对应的元素。比如：二分查找。</p><p>劣势体现在插入和删除方面，由于数组元素连续紧密地存储在内存中，插入和删除元素都会导致大量的元素被迫移动，影响效率。</p><p>总体来说，数组适合的是读操作多，写操作少的场景。</p><h4 id="1-2-链表"><a href="#1-2-链表" class="headerlink" title="1.2 链表"></a>1.2 链表</h4><p>链表是一种在物理上非连续、非顺序的数据结构，由若干节点组成。</p><p>单项链表的每一个节点又包含两部分，一部分是存放数据的变量data，另一部分是指向下一个节点的指针next。</p><p>双向链表每个节点除了拥有data和next指针，还有指向前置节点的prev指针。</p><p>如果说数组在内存中存储方式是顺序存储，那么链表在内存中的存储方式是随机存储。</p><h5 id="1-2-1-链表的基本操作"><a href="#1-2-1-链表的基本操作" class="headerlink" title="1.2.1 链表的基本操作"></a>1.2.1 链表的基本操作</h5><p>查找的时间复杂度是<code>O(n)</code></p><p>不考虑查找过程，插入和删除的时间复杂度是<code>O(1)</code></p><ol><li><p>查找节点</p><p>链表只能从头节点开始向后一个一个节点逐一查找。</p></li><li><p>更新节点</p><p>忽略查找的过程，和数组类似</p></li><li><p>插入</p><ul><li><p>尾部插入</p><p>把最后一个节点的next指针指向新插入的节点即可</p></li><li><p>头部插入</p><p>把新节点的next指针指向原先的头结点</p><p>把新节点变为链表的头结点（指针）</p></li><li><p>中间插入</p><p>新节点的next指针，指向插入位置的节点</p><p>插入位置的前置节点的next指针指向新节点</p></li></ul><p>只要内存空间允许，能够插入链表的元素时无穷无尽的，不需要考虑扩容的问题。</p></li><li><p>删除元素</p><ul><li><p>尾部删除</p><p>把倒数第二个节点的next指针指向空即可</p></li><li><p>头部删除</p><p>把链表的头节点设为原先头节点的next指针即可</p></li><li><p>中间删除</p><p>把要删除节点的前置节点的next指针，指向要删除的元素的下一个节点即可</p></li></ul></li></ol><h4 id="1-3-数组VS链表"><a href="#1-3-数组VS链表" class="headerlink" title="1.3 数组VS链表"></a>1.3 数组VS链表</h4><div class="table-container"><table><thead><tr><th></th><th>查找</th><th>更新</th><th>插入</th><th>删除</th></tr></thead><tbody><tr><td>数组</td><td>O(1)</td><td>O(1)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>链表</td><td>O(n)</td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr></tbody></table></div><p>数组的优势在于能够快速的定位元素，对于读操作多、写操作少的场景，用数组更合适。</p><p>链表的优势在于能够灵活的进行插入和删除操作，如果需要在尾部频繁插入，删除元素，用链表更合适一些。、</p><h3 id="2-栈和队列"><a href="#2-栈和队列" class="headerlink" title="2. 栈和队列"></a>2. 栈和队列</h3><p>物理结构、逻辑结构：</p><img src="/2019/11/19/algorithm[算法]/4.数据结构/逻辑结构和物理结构.png" class="slug"><h4 id="2-1-栈"><a href="#2-1-栈" class="headerlink" title="2.1 栈"></a>2.1 栈</h4><p>栈是一种线性数据结构，栈内元素只能先入后出。最早进入的元素存放的位置叫做栈底，最后进入的元素存放的位置叫做栈顶。</p><h5 id="2-1-1-栈的基本操作"><a href="#2-1-1-栈的基本操作" class="headerlink" title="2.1.1 栈的基本操作"></a>2.1.1 栈的基本操作</h5><p>入栈和出栈的时间复杂度都是<code>O(1)</code></p><ol><li><p>入栈（push）</p><p>只允许从栈顶一侧放入数据，新元素会成为栈顶</p></li><li><p>出栈（pop）</p><p>只有栈顶元素才允许出栈，出栈元素的前一个元素将会成为新的栈顶</p></li></ol><h4 id="2-2-队列"><a href="#2-2-队列" class="headerlink" title="2.2 队列"></a>2.2 队列</h4><p>对列是一种线性数据结构，队列中的元素只能先入先出，队列的出口端叫做队头，队列的入口端叫做队尾</p><h5 id="2-2-1-队列的基本操作"><a href="#2-2-1-队列的基本操作" class="headerlink" title="2.2.1 队列的基本操作"></a>2.2.1 队列的基本操作</h5><p>入队和出队的时间复杂度为<code>O(1)</code></p><ol><li>入队（enqueue）</li><li>出队（dequeue）</li></ol><p>用数组实现的队列可以采用循环队列的方式来维持队列容量的恒定。</p><p>假设一个队列经过反复的入队和出队操作，还剩下两个元素，在物理上 分布于数组的末尾位置。这是又有一个新元素要入队</p><img src="/2019/11/19/algorithm[算法]/4.数据结构/队列01.png" class="slug"><p>在数组不做扩容的前提下，我们可以利用已出队元素留下的空间，让队尾指针重新指回数组的首位。</p><img src="/2019/11/19/algorithm[算法]/4.数据结构/队列02.png" class="slug"><p>这样一来整个队列的元素就”循环”起来了。在物理存储上，队尾的位置也可以在对头之前。当再有元素入队时，将其放在数组首位，队尾指针继续后移即可。</p><img src="/2019/11/19/algorithm[算法]/4.数据结构/队列03.png" class="slug"><p>一直到<code>(队尾下标 + 1) % 数组长度 = 对头下标</code> 时，代表队列真的已经满了，需要注意的是，队尾指针指向的位置永远空出一位，所以队列最大容量比数组长度小1。</p><h4 id="2-3-栈和队列的应用"><a href="#2-3-栈和队列的应用" class="headerlink" title="2.3 栈和队列的应用"></a>2.3 栈和队列的应用</h4><h5 id="2-3-1-栈的应用"><a href="#2-3-1-栈的应用" class="headerlink" title="2.3.1 栈的应用"></a>2.3.1 栈的应用</h5><p>栈的输出顺序和输入顺序相反，所以栈通常用于对历史的回溯</p><p>例如实现递归的逻辑，就可以用栈来代替，因为栈可以回溯方法的调用链</p><p>栈还有一个著名的应用场景是面包屑导航。</p><h5 id="2-3-2-队列的应用"><a href="#2-3-2-队列的应用" class="headerlink" title="2.3.2 队列的应用"></a>2.3.2 队列的应用</h5><p>队列的输出顺序和输入顺序相同，所以队列通常用于对历史的回放。</p><p>在多线程中，争夺公平锁的等待队列</p><p>网络爬虫实现网站抓取，把待抓取的url存入队列</p><h5 id="2-3-3-双端队列"><a href="#2-3-3-双端队列" class="headerlink" title="2.3.3 双端队列"></a>2.3.3 双端队列</h5><p>双端队列这种数据结构，综合了栈和队列的优点，对双端队列来说，从对头的一端可以入队或出队，从队尾的一端也可以入队或出队</p><h5 id="2-3-4-优先队列"><a href="#2-3-4-优先队列" class="headerlink" title="2.3.4 优先队列"></a>2.3.4 优先队列</h5><p>遵循谁的优先级最高，谁先出队。</p><h3 id="3-散列表"><a href="#3-散列表" class="headerlink" title="3. 散列表"></a>3. 散列表</h3><p>散列表也叫做哈希表，这种数据结构提供了key和value的映射关系，只要给出一个key，就可以高效的查找它所匹配的value，时间复杂度接近于<code>O(1)</code>。</p><h4 id="3-1-哈希函数"><a href="#3-1-哈希函数" class="headerlink" title="3.1 哈希函数"></a>3.1 哈希函数</h4><p>通过某种方式，把key和数组下标进行转换。</p><h4 id="3-2-散列表的读写操作"><a href="#3-2-散列表的读写操作" class="headerlink" title="3.2 散列表的读写操作"></a>3.2 散列表的读写操作</h4><ol><li><p>写操作</p><p>就是在散列表中插入新的键值对。</p><p>如调用<code>hashMap.put(&quot;002931&quot;, &quot;王五&quot;)</code>，意思就是插入一组key为002931、value为王五的键值对。</p><p>具体步骤：</p><ul><li><p>通过哈希函数，把key转化成数组下标5</p></li><li><p>如果数组下标5对应的位置没有元素，就把这个Entry填充到数组下标5的位置。</p><img src="/2019/11/19/algorithm[算法]/4.数据结构/hash散列表01.png" class="slug"></li></ul><p>但是，由于数组的长度是有限的，当插入的Entry越来越多时，不同的key通过哈希函数获得的下标有可能是相同的。例如<code>002936</code>这个key对应的数组下标是2；</p><img src="/2019/11/19/algorithm[算法]/4.数据结构/hash散列表02.png" class="slug"><p><code>002947</code>这个key对应的数组下标也是2。这就产生了哈希<strong>冲突</strong>。</p><p>解决哈希冲突的方法有两种，一种开放寻址法，一种是链表法。</p><ul><li><p>开放寻址法</p><p>当一个key通过哈希函数获得对应的数组下标已被占用时，可以去寻找下一个空挡位置。</p><p>以上面的情况为例，Entry6通过哈希函数得到下标2，该下标在数组中已经有了其他元素，那么就向后移动1位，看看数组下标3的位置是否有空</p><img src="/2019/11/19/algorithm[算法]/4.数据结构/开放寻址法01.png" class="slug"><p>很不巧，下标3也已经被占用，那么久再向后移动一位，看看数组下标4的位置是否有空。</p><img src="/2019/11/19/algorithm[算法]/4.数据结构/开放寻址法02.png" class="slug"><p>幸运的是，数组下标4的位置还没有被占用，因此把Entry6存入下标4的位置</p><img src="/2019/11/19/algorithm[算法]/4.数据结构/开放寻址法03.png" class="slug"><p>这就是开放寻址法的基本思路。</p></li><li><p>链表法</p><p>这种方法被应用在java的集合类HashMap中</p><p>HashMap数组的每一个元素不仅是一个Entry对象，还是一个链表的头节点。每一个Entry对象通过next指针指向它的下一个Entry节点。当新来的Entry映射到与之冲突的数组位置时，只需要插入到对应的链表中即可。</p><img src="/2019/11/19/algorithm[算法]/4.数据结构/链表法.png" class="slug"></li></ul></li><li><p>读操作</p><p>读操作就是通过给定的key，在散列表中查找对应的value。</p><p>例如：调用<code>hashMap.get(&quot;002936&quot;)</code>，意思是查找key为002936的Entry在散列表中所对应的值。以链表法为例</p><ul><li><p>通过哈希函数，把key转化成数组的下标2</p></li><li><p>找到数组下标2所对应的元素，如果这个元素的key是002936那么久找到了；如果不是，由于数组的每个元素都与一个链表对应，我们可以顺着链表慢慢往下找。</p><img src="/2019/11/19/algorithm[算法]/4.数据结构/散列表读操作.png" class="slug"><p>上图中，首先查到的节点Entry6的key是002974，和待查找的key002936不符，接着定位到列表下一个节点Entry1，发现Entry1的key002936正是我们要寻找的，所以返回Entry1的value即可。</p></li></ul></li><li><p>扩容（resize）</p><p>当经过多次元素插入，散列表达到一定饱和时，key映射位置发生冲突的概率会逐渐提高。这样一来，大量的元素拥挤在相同的数组下标位置，形成很长的链表，对后续插入操作和查询操作的性能都有很大影响。</p><img src="/2019/11/19/algorithm[算法]/4.数据结构/散列表扩容.png" class="slug"><p>这时，散列表就需要扩展它的长度，也就是进行扩容。</p><p>对于JDK中的散列表实现类HashMap来说，影响其扩容的因素有两个。</p><ul><li>Capacity，即HashMap的当前长度</li><li>LoadFactor，即HashMap的负载因子，默认值为0.75f</li></ul><p>衡量HashMap需要进行扩容的条件如下。</p><p><code>HashMap.Size &gt;= Capacity × LoadFactor</code></p><p>扩容的步骤：</p><ul><li>扩容，创建一个新的Entry空数组，长度是原数组的2倍。</li><li>重新Hash，遍历原Entry数组，把所有的Entry重新hash到新数组中。为什么要重新Hash呢？因为长度扩大以后，Hash的规则也随之改变。</li></ul><p>经过扩容，原本拥挤的散列表重新变得稀疏，原有的Entry也重新得到了尽可能均匀的分配。</p><img src="/2019/11/19/algorithm[算法]/4.数据结构/扩容前后HashMap.png" class="slug"></li></ol><h3 id="注"><a href="#注" class="headerlink" title="注"></a>注</h3><p>python中的list在内存中是连续的，之所以不需要考虑扩容的问题，是因为list是动态扩容。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-数组和链表&quot;&gt;&lt;a href=&quot;#1-数组和链表&quot; class=&quot;headerlink&quot; title=&quot;1. 数组和链表&quot;&gt;&lt;/a&gt;1. 数组和链表&lt;/h3&gt;&lt;h4 id=&quot;1-1-数组&quot;&gt;&lt;a href=&quot;#1-1-数组&quot; class=&quot;headerlink&quot; title=&quot;1.1 数组&quot;&gt;&lt;/a&gt;1.1 数组&lt;/h4&gt;&lt;p&gt;数组是有限个相同类型的变量所组成的有序集合，数组中的每一个变量被称为元素。&lt;/p&gt;
&lt;p&gt;数组中的每一个元素，都存储在内存单元中，并且元素之间紧密排列，既不能打乱元素的存储顺序，也不能跳过某个存储单元进行存储。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://blog.silencew.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://blog.silencew.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
