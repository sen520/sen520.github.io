---
title: javascript 函数
date: 2019-11-11
updated: 2019-11-11
categories:
- javascript
---

#### 构造器函数

在一个函数前面带上`new`来调用，那么将创建一个隐藏的连接到该函数的`prototype`成员的新对象，同时this将会被绑定到那个新对象上。

new 前缀也会改变return语句的行为

```javascript
// 创建一个名为Quo的构造器函数，它构造一个带有status属性的对象
var Quo = function (string) {
  this.status = string;
}

// 给Quo的所有实例提供一个名为get_status的公共方法
Quo.prototype.get_status = function() {
  return this.status;
}

// 构造一个Quo实例
var myQuo = new Quo("confused")
console.log(myQuo.get_status());
// confused
```

其目的就是结合new前缀调用的函数被称为构造器函数。按照约定，他们保存在以大写格式命名的变量里。如果调用构造器函数时没有在前面加上new，**不会有任何报错和警告**，但是在调用的时候会出现问题。

#### Apply 调用模式

apply 方法让我们构建一个参数数组并用其去调用函数。他也允许我们选择this的值，apply方法接收两个参数，第一个是将被绑定给this的值，第二个就是一个参数数组。

```javascript
// 构造一个包含两个数字的数组，并将它们相加
var add = function (a, b) {
  return a + b;
}
var array = [3, 4];
var sum = add.apply(null, array);

// 构造一个包含status成员的对象
var statusObject = {
  status: 'A-OK'
}
// statusObject并没有继承自 Quo.prototype，但我们可以在statusObject上调用get_status方法，尽管statusObject并没有一个名为get_status的方法

var status = Quo.prototype.get_status.apply(statusObject);
// status 值为 'A-OK'
```

#### 参数

当函数被调用时，会得到一个免费奉送的参数，那就是`arguments`数组，通过它函数可以访问所有它被调用时传递给它的参数列表，包括那些没有被分配给函数声明时定义的形式参数的多余参数。

```javascript
var sum = function() {
  var i, sum = 0;
  for (i = 0; i < arguments.length; i+= 1) {
    sum += arguments[i];
  }
  return sum;
}
console.log(sum(1,2,3,4,5))
// 15
```

arguments 并不是一个真正的数组。他只是一个`类似数组(array-like)`的对象。arguments拥有一个length属性，但它缺少所有的数组方法。

#### 给类型增加方法

javascript允许给语言的基本类型增加方法。

我们可以通过给`Function.prototype`增加方法来使得该方法对所有函数可用

```javascript
Function.prototype.method = function (name, func) {
  this.prototype[name] = func;
  return this;
}
```

通过给`Function.prototype`增加一个method方法，我们就不必键入prototype这个属性名。

javascript并没有单独的整数类型，因此有时候只提取数字中的整数部分是有必要的。我们可以通过给`Number.prototype`添加一个integer方法来改善它。他会根据数字的正负来判断是使用`Math.ceiling`还是`Math.floor`。

```javascript
Number.method('integer', function(){
  return Math[this < 0 ? 'ceil' : 'floor'](this);
})
console.log((-10/3).integer())
// -3
```

注意：**基础类型的原型是公共的结构，所以在类库混用时务必小心，这种操作需要在确定没有该方法的时候才能添加**

#### 闭包

```javascript
// 创键一个名为quo的构造函数
// 它构造出带有get_status方法和status私有属性的一个对象
var quo = function(status) {
  return {
    get_status: function (){
      return status;
    }
  };
};
var myQuo = quo('amazed');
console.log(myQuo.get_status);
// amazed
```

这个quo函数被设计成无须在前面加上new来使用，所以名字也没有首字母大写。当我们调用quo时，它返回包含get_status方法的一个新对象。该对象的一个引用保存在myQuo中。即使quo已经返回了，但get_status方法仍然享有访问quo对象的status属性的特权。get_status方法并不是访问该参数的一个拷贝；它访问的就是该参数本身。这是可能的，因为该函数可以访问它被创建时所处的上下文环境，这被称为闭包。

下面一个例子：

```javascript
var fade = function (node) {
    var level = 1;
    var step = function () {
        var hex = level.toString(16);
        node.style.backgroundColor = '#FFFF' + hex + hex;
        if (level <15) {
            level += 1;
            setTimeout(step, 100);
        }
    };
    setTimeout(step, 100);
};
fade(document.body)
```

我们调用fade，把document.body作为参数传递给它（HTML\<body\>标签所创建的节点）。fade函数设置level为1。它定义了一个step函数，接着调用setTimeout，并传递step函数和一个时间（100毫秒）给它，然后返回。

在大约十分之一秒后step函数被调用，它把fade函数的level变量转化为16位字符。接着，它修改fade函数得到的节点的背景颜色。然后查看fade函数的level变量。如果背景色尚未变成白色，那么它增大fade函数的level变量和用setTimeout预订让它自己再次运行。

step函数很快再次被调用，但这次，fade函数的level变量值变成2，fade函数在之前已经返回了，但只要fade的内部函数需要，它的变量就会持续保留。