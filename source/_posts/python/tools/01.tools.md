---
title: tools
date: 2019-10-18 13:54:28
tag:
- python
categories:
- python
- tools
---

#### 小工具

##### 缓存

缓存，其作用是缓和较慢存储的高频次请求，简单来说就是加速慢存储的访问效率。

我们可以通过设定一个字典来放置查询，key-value:查询条件-查询结果

在查询之前，先查看该字典中有无该key的存在，如果有，不走查询，如果没有，查询之后将查询结果保存在该字典中。

- 设置一个dict来存储缓存
- 缓存的大小，过期时间，访问时间
- 超过大小要删除，超过过期时间要删除

```python
import time
from collections import OrderedDict


class LRUCacheDict:
    def __init__(self, max_size=1024, expiration=60):
        """ 最大容量为1024个key，每个key的有效期是60s """
        self.max_size = max_size
        self.expiration = expiration
        self._cache = {}
        self._access_records = OrderedDict()  # 记录访问时间
        self._expire_records = OrderedDict()  # 记录失效时间

    def __setitem__(self, key, value):
        now = int(time.time())
        self.__delete__(key)
        self._cache[key] = value
        self._expire_records[key] = now + self.expiration
        self._access_records[key] = now

        self.cleanup()

    def __getitem__(self, key):
        now = int(time.time())
        del self._access_records[key]
        self._access_records[key] = now
        self.cleanup()

    def __contains__(self, key):
        self.cleanup()
        return key in self._cache

    def __delete__(self, key):
        if key in self._cache:
            del self._cache[key]
            del self._expire_records[key]
            del self._access_records[key]

    def cleanup(self):
        """去掉无效的过期的超出大小的缓存"""
        if self.expiration is None:
            return None
        pending_delete_keys = []
        now = int(time.time())
        for k, v in self._expire_records.items():
            if v < now:
                pending_delete_keys.append(k)
        for del_k in pending_delete_keys:
            self.__delete__(del_k)

        while (len(self._cache) > self.max_size):
            for k in self._access_records:
                self.__delete__(k)
                break

if __name__ == '__main__':
    cache_dict = LRUCacheDict(max_size=2, expiration=10)
    cache_dict['name']='test'
    cache_dict['age'] = 30
    cache_dict['addr'] = 'beijing'

    print('name' in cache_dict)
    print('age' in cache_dict)
    time.sleep(11)
    print('age' in cache_dict)
```

- 实现dict：我们通过了一些内置的方法(`__getitem__`和`__setitem__`)实现了一个dict对象。
- 缓存淘汰算法的使用：这里实现的是LRU算法。值得注意的是，我们实现的这个缓存字典是非线程安全的。
- OrderedDict的使用：用它的目的就是保证顺序，让我们每次遍历都能够从最早放进去的数据开始。

可以将调用上述代码，并封装成装饰器

```python
def cache_it(max_size=1024, expiration=60):
    CACHE = LRUCacheDict(max_size=max_size, expiration=expiration)

    def wrapper(func):
        @functools.wraps(func)
        def inner(*args, **kwargs):
            key = repr(*args, **kwargs)
            try:
                result = CACHE[key]
            except KeyError:
                result = func(*args, **kwargs)
                CACHE[key] = result
            return result

        return inner

    return wrapper


@cache_it(max_size=10, expiration=3)
def query(sql):
    time.sleep(1)
    result = 'execute %s' % sql
    return result
```

###### 注意：

python3中LRUCache已经是标准库中的一部分了，可以通过`functools.lru_cache`来使用

