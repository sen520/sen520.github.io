---
title: 树
date: 2019-11-20
updated: 2019-11-20
tags:
- 算法
categories:
- 算法
---

树（tree）是n（n<=0）个节点的有限集。当n=0时，成为空树。在任意一个非空树中，有如下特点：

- 有且仅有一个特定的成为根的节点。
- 当n>1时，其余节点可分为m（m>0）个互不相交的有限集，每一个集合本身又是一个树，并称为根的子树

<!--more-->

{% asset_img slug 树01.png %}

{% asset_img slug 树02.png %}

树的最大层级数，被称为树的高度或深度，上面这个数的高度是4

#### 二叉树

二叉树（binary tree）是树的一种特殊形式。这种树的每个节点最多有两个孩子节点。

{% asset_img slug 二叉树01.png %}

二叉树有两种特殊的形式，一个叫做满二叉树，另一个叫完全二叉树。

- 满二叉树

  一个二叉树的所有非叶子节点都存在左右孩子，并且所有的叶子节点都在同一层级上；简单来说，满二叉树的每一个分支都是满的

  {% asset_img slug 满二叉树.png %}

- 完全二叉树

  对一个有n个节点的二叉树，按层级顺序编号，则所有的节点的编号为从1到n。如果这个树所有节点和同样深度的满二叉树的编号为从1到n的节点位置相同，则这个二叉树为完全二叉树。

  {% asset_img slug 完全二叉树.png %}

  上图中，二叉树编号从1到12的12个节点，和前面满二叉树从1到12的节点位置完全对应，因此这个树是完全二叉树。

完全二叉树的条件没有满二叉树那么苛刻：满二叉树要求所有分支都是满的；而完全二叉树只需保证最后一个节点之前的节点都齐全即可。

存储结构：

- 链式存储结构

  {% asset_img slug 链式二叉树.png %}

  链式存储是二叉树最直观的存储方式。

  一个节点最多可以指向左右两个孩子节点，所以二叉树的每一个节点包含3部分

  - 存储数据的data变量
  - 指向左孩子的left指针
  - 指向右孩子的right指针

- 数组

  {% asset_img slug 数组二叉树.png %}

  使用数组存储时，会按照层级顺序把二叉树的节点放到数组中对应的位置。如果某一个节点的左孩子或者右孩子空缺，则数组的相应位置也空出来。

  这样设计可以更方便的在数组中定位二叉树的孩子节点和父节点。

  假设一个父节点的下标是parent，那么它的左孩子节点下标就是`2 × parent + 1 `，右孩子节点的下标就是`2 × parent + 2`

  反过来，一个左孩子节点下标是leftChild，那么它的父节点的下标就是`(leftChild - 1) / 2`

对于一个稀疏的二叉树来说，用数组表示法是非常浪费空间的。

##### 二叉树的应用

###### 1. 查找

二叉查找树

- 如果左子树不为空，则左子树上所有节点的值均小于根节点的值
- 如果右子树不为空，则右子树上所有节点的值均大于根节点的值
- 左右子树也都是二叉查找树

{% asset_img slug 二叉查找树01.png %}

例如查找值为4的节点

- 访问根节点6，发现4 < 6

  {% asset_img slug 二叉查找树02.png %}

- 访问节点6的左孩子节点3，发现4 > 3

  {% asset_img slug 二叉查找树03.png %}

- 访问节点3的右孩子节点4，发现4 = 4，正是要找的节点

  {% asset_img slug 二叉查找树04.png %}

对于一个节点分布相对均衡的二叉查找树来说，如果节点总数是n，那么搜索节点的时间复杂度就是`O(logn)`，和树的深度是一样的。

###### 2. 维持相对顺序

仍然要从二叉查找树说起，二叉查找树要求左子树小于父节点，右子树大于父节点，正是这样保证了二叉树的有序性。

因此二叉查找树又叫二叉排序树

新插入的节点，同样要遵循二叉排序树的原则，例如插入新元素5，由于5 < 6, 5 > 3, 5 > 4，所以最终为插入节点4的右孩子的位置

{% asset_img slug 二叉查找树05.png %}

这样却隐藏了一个致命的问题，在二叉查找树中依次插入9、8、7、6、5、4会出现下面这种情况

{% asset_img slug 二叉查找树06.png %}

这就涉及到了二叉树的自平衡，后面会说到

##### 二叉树的遍历

分为4种：前序遍历，中序遍历，后序遍历，层序遍历

从更宏观的角度来看，二叉树的遍历归结为两大类：

- 深度优先遍历（前序遍历，中序遍历，后序遍历）
- 广度优先遍历（层序遍历）

###### 深度优先遍历

- 前序遍历

  输出顺序是根节点，左子树，右子树

  {% asset_img slug 前序遍历.png %}

- 中序遍历

  输出顺序是左子树，根节点，右子树

  {% asset_img slug 中序遍历.png %}

- 后序遍历

  输出顺序是左子树，右子树，根节点

  {% asset_img slug 后序遍历.png %}

递归的方式

非递归方式（栈）

1. 首先遍历二叉树的根节点，放入栈中。

   {% asset_img slug 二叉树非递归遍历01.png %}

2. 遍历根节点1的左孩子节点2，放入栈中。

   {% asset_img slug 二叉树非递归遍历02.png %}

3. 遍历节点2的左孩子节点4，放入栈中。

   {% asset_img slug 二叉树非递归遍历03.png %}

4. 节点4既没有左孩子，也没有右孩子，我们需要回溯到上一个节点2。

   因为栈已经存储了刚才遍历的路径。让旧的栈顶元素4出栈，就可以重新访问节点2，得到节点2的右孩子节点5.

   此时节点2已经没有利用价值了，节点2出栈，节点5入栈。

   {% asset_img slug 二叉树非递归遍历04.png %}

5. 节点5既没有左孩子，也没有右孩子，我们需要再次回溯，一直回溯到节点1，所以让节点5出栈，根节点1的右孩子是节点3，节点1出栈，节点3入栈。

   {% asset_img slug 二叉树非递归遍历05.png %}

6. 节点3的右孩子是节点6，节点3出栈，节点6入栈

   {% asset_img slug 二叉非树递归遍历06.png %}

7. 节点6既没有左孩子，也没有右孩子，所以节点6出栈。此时栈为空，遍历结束。

   {% asset_img slug 二叉树非递归遍历07.png %}

```java
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Stack;

public class helloword {
    /**
     * 构建二叉树
     *
     * @param inputList 输入序列
     */
    public static TreeNode createBinaryTree(LinkedList<Integer> inputList) {
        TreeNode node = null;
        if (inputList == null || inputList.isEmpty()) {
            return null;
        }
        Integer data = inputList.removeFirst();
        if (data != null) {
            node = new TreeNode(data);
            node.leftChild = createBinaryTree(inputList);
            node.rightChild = createBinaryTree(inputList);
        }
        return node;
    }

    /**
     * 二叉树的前序遍历
     *
     * @param node 二叉树节点
     */
    public static void preOrderTraveral(TreeNode node) {
        if (node == null) {
            return;
        }
        System.out.println(node.data);
        preOrderTraveral(node.leftChild);
        preOrderTraveral(node.rightChild);
    }


    /**
     * 二叉树的中序遍历
     *
     * @param node 二叉树节点
     */
    public static void inOrderTraveral(TreeNode node) {
        if (node == null) {
            return;
        }
        inOrderTraveral(node.leftChild);
        System.out.println(node.data);
        inOrderTraveral(node.rightChild);
    }

    /**
     * 二叉树的后序遍历
     *
     * @param node 二叉树节点
     */
    public static void postOrderTraveral(TreeNode node) {
        if (node == null) {
            return;
        }
        postOrderTraveral(node.leftChild);
        postOrderTraveral(node.rightChild);
        System.out.println(node.data);
    }

    /**
     * 二叉树节点
     */
    private static class TreeNode {
        int data;
        TreeNode leftChild;
        TreeNode rightChild;

        TreeNode(int data) {
            this.data = data;
        }
    }

    /**
     * 二叉树非递归前序遍历
     *
     * @param root 二叉树根节点
     */
    public static void preOrderTraveralWithStack(TreeNode root) {
        Stack<TreeNode> stack = new Stack<TreeNode>();
        TreeNode treeNode = root;
        while(treeNode != null || !stack.isEmpty()) {
            // 迭代访问节点的左孩子，并入栈
            while (treeNode != null) {
                System.out.println(treeNode.data);
                stack.push(treeNode);
                treeNode = treeNode.leftChild;
            }
            // 如果节点没有左孩子，则弹出栈顶节点，访问节点右孩子
            if (!stack.isEmpty()) {
                treeNode = stack.pop();
                treeNode = treeNode.rightChild;
            }
        }
    }

    public static void main(String[] args) {
        LinkedList<Integer> inputList = new LinkedList<Integer>(Arrays.asList(new Integer[]{3, 2, 9, null, null, 10, null, null, 8, null, 4}));
        TreeNode treeNode = createBinaryTree(inputList);
        System.out.println("前序遍历: ");
        preOrderTraveral(treeNode);
        System.out.println("无递归实现前序遍历: ");
        preOrderTraveralWithStack(treeNode);
        System.out.println("中序遍历: ");
        inOrderTraveral(treeNode);
        System.out.println("后序遍历: ");
        postOrderTraveral(treeNode);
    }
}

```

###### 广度优先遍历

{% asset_img slug 二叉树广度优先遍历.png %}

1. 根节点1进入队列

   {% asset_img slug 二叉树广度优先遍历01.png %}

2. 节点1出队，输出节点1，并得到节点1的左孩子节点2、右孩子节点3.让节点2和节点3入队。

   {% asset_img slug 二叉树广度优先遍历02.png %}

3. 节点2出队，输出节点2，并得到节点2的左孩子4、右孩子节点5。让节点4和节点5入队。

   {% asset_img slug 二叉树广度优先遍历03.png %}

4. 节点3出队，输出节点3，并得到节点三的右孩子节点6。让节点6入队

   {% asset_img slug 二叉树广度优先遍历04.png %}

5. 节点4出队，输出节点4，由于节点4没有孩子节点，所以没有新节点入队

   {% asset_img slug 二叉树广度优先遍历05.png %}

6. 节点5出队，输出节点5，由于节点5同样没有孩子节点，所以没有新节点入队。

   {% asset_img slug 二叉树广度优先遍历06.png %}

7. 节点6出队，输出节点6，节点6没有孩子节点，没有新节点入队

   {% asset_img slug 二叉树广度优先遍历07.png %}

```java
    /*
    * 二叉树层序遍历
    * @param root 二叉树根节点
    * */
    public static void levelOrderTraversal(TreeNode root){
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.offer(root);
        while(!queue.isEmpty()){
            TreeNode node = queue.poll();
            System.out.println(node.data);
            if (node.leftChild != null){
                queue.offer(node.leftChild);
            }
            if (node.rightChild != null) {
                queue.offer(node.rightChild);
            }
        }
    }
```

#### 二叉堆

二叉堆本质上是一种完全二叉树，分为两个类型

- 最大堆

  最大堆的任何一个父节点的值，都大于或等于它左、右孩子节点的值。

  {% asset_img slug 最大堆.png %}

- 最小堆

  最小堆的任何一个父节点的值，都小于或等于它左、右孩子节点的值。

  {% asset_img slug 最小堆.png %}

二叉树的根节点叫做堆顶。

最大堆和最小堆的特点决定了：最大堆的堆顶是整个堆中的最大元素；最小堆的堆顶是整个堆中的最小元素。

##### 二叉堆的自我调整

堆的插入和删除操作时间复杂度是`O(logn)`

节点的上浮和下沉时间复杂度是`O(logn)`

构建的时间复杂度是`O(n)`

1. 插入节点

   当二叉堆插入节点时，插入位置是完全二叉树的最后一个位置。例如插入一个新节点，值是0

   {% asset_img slug 二叉堆插入节点01.png %}

   这时，新节点的父节点5比0大，显然不符合最小堆的性质，于是让新节点“上浮”，和父节点交换位置

   {% asset_img slug 二叉堆插入节点02.png %}

   继续用节点0和父节点3作比较，因为0小于3，则让新节点继续上浮

   {% asset_img slug 二叉堆插入节点03.png %}

   最终新节点0“上浮”到了堆顶位置

   {% asset_img slug 二叉堆插入节点04.png %}

2. 删除节点

   二叉堆删除节点的过程和插入节点的过程正好相反，所删除的是处于堆顶的节点1

   {% asset_img slug 二叉堆删除节点01.png %}

   这时，为了继续维持完全二叉树的结构，我们把堆的最后一个节点10临时补到原本的堆顶位置。

   {% asset_img slug 二叉堆删除节点02.png %}

   接下来，让暂处栈顶位置的节点10和它的左、右孩子节点中最小的一个，显然是节点2，那么让节点10“下沉”。

   {% asset_img slug 二叉堆删除节点03.png %}

   继续让节点10和它的左右孩子作比较，左右孩子中最小的节点7，由于10大于7，让节点10继续“下沉”

   {% asset_img slug 二叉堆删除节点04.png %}

   这样，二叉堆重新得到了调整

3. 构建二叉堆

   构建二叉堆就是把一个完全无序的二叉树调整为二叉堆，本质就是让所有的非叶子节点依次下沉。

   {% asset_img slug 构建二叉堆01.png %}

   首先，从最后一个非叶子节点开始，也就是从节点10开始。如果节点10大于它左、右孩子节点中最小的一个，则节点10下沉

   {% asset_img slug 构建二叉堆02.png %}

   接下来轮到节点3，如果节点3,大于它左、右孩子节点中最小的一个，则节点3下沉

   {% asset_img slug 构建二叉堆03.png %}

   然后轮到节点1，如果节点1大于它左、右孩子节点中最小的一个，则节点1下沉。

   接下来轮到节点7，如果节点7大于它左、右孩子节点中最小的一个，则节点7下沉

   {% asset_img slug 构建二叉堆04.png %}

   节点7继续比较，继续下沉

   {% asset_img slug 构建二叉堆05.png %}

   经过上述的几轮比较和下沉，最终每一节点都小于它的左右孩子节点，一个无序的完全二叉树就被构建成了一个最小堆。

##### 代码实现

二叉堆虽然是一个完全二叉树，但它的存储方式并不是链式的，而是顺序存储。二叉堆的所有节点都存储在数组中

{% asset_img slug 二叉堆的存储.png %}

```java
import java.util.Arrays;

public class test {
    /*
     * “上浮”调整
     * @param array 待调整的堆
     * */
    public static void upAdjust(int[] array) {
        int childIndex = array.length - 1;
        int parentIndex = (childIndex - 1) / 2;
        // temp 保存插入的叶子节点值，用于最后的赋值
        int temp = array[childIndex];
        while (childIndex > 0 && temp < array[parentIndex]) {
            // 无须真正交换，单向赋值即可
            array[childIndex] = array[parentIndex];
            childIndex = parentIndex;
            parentIndex = (parentIndex - 1) / 2;
        }
        array[childIndex] = temp;
    }

    /*
     * “下沉”调整
     * @param array 待调整的堆
     * @param parentIndex 要“下沉”的父节点
     * @param length 堆的有效大小
     * */
    public static void downAdjust(int[] array, int parentIndex, int length) {
        // temp 保存父节点值，用于最后的赋值
        int temp = array[parentIndex];
        int childIndex = 2 * parentIndex + 1;
        while (childIndex < length) {
            // 如果有右孩子，且右孩子小于左孩子的值，则定位到右孩子
            if (childIndex + 1 < length && array[childIndex + 1] < array[childIndex]) {
                childIndex++;
            }
            // 如果父节点小于任何一个孩子的值，则直接跳出
            if (temp <= array[childIndex]) break;
            // 无需真正的交换，单向赋值即可
            array[parentIndex] = array[childIndex];
            parentIndex = childIndex;
            childIndex = 2 * childIndex + 1;
        }
        array[parentIndex] = temp;
    }

    /*
     * 构建堆
     * @param array 待调整的堆
     * */
    public static void buildHeap(int[] array) {
        // 从最后一个非叶子节点开始，依次下沉调整
        for (int i = (array.length - 2) / 2; i >= 0; i--) {
            downAdjust(array, i, array.length);
        }
    }

    public static void main(String[] args) {
        int[] array = new int[]{1, 3, 2, 6, 5, 7, 8, 9, 10, 0};
        upAdjust(array);
        System.out.println(Arrays.toString(array));

        array = new int[]{7, 1, 3, 10, 5, 2, 8, 9, 6};
        buildHeap(array);
        System.out.println(Arrays.toString(array));
    }
}

```

#### 优先队列

优先队列不再遵循先入先出的原则，而是分为两种情况

- 最大优先队列，无论入队顺序如何，都是当前最大的元素优先出队
- 最小优先队列，无论入队顺序如何，都是当前最小的元素优先出队

对列的入队和出队与二叉堆的插入和删除一致，所以时间复杂度也是`O(logn)`

