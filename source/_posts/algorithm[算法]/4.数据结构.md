---
title: 数据结构
date: 2019-11-19
updated: 2019-11-20
tags:
- 算法
categories:
- 算法
---

### 1. 数组和链表

#### 1.1 数组

数组是有限个相同类型的变量所组成的有序集合，数组中的每一个变量被称为元素。

数组中的每一个元素，都存储在内存单元中，并且元素之间紧密排列，既不能打乱元素的存储顺序，也不能跳过某个存储单元进行存储。

<!--more-->

##### 1.1.1 数组的基本操作

更新和读取的时间复杂度是`O(1)`

插入和删除的时间复杂度是`O(n)`

还有一种删除操作：如果数组无序，把最后一个元素复制到要删除元素的位置，然后删除最后一个元素。这样时间复杂度为`O(1)`

1. 读取元素

   由于数组在内存中顺序存储，所以只要给出一个数组下标，就可以读取到对应的数组元素。

   根据下标读取元素的方式叫做随机读取

   ```java
   int[] array = new int[]{3,1,2,5,4,9,7,2};
   // 输出数组中下标为3的元素
   System.out.println(array[3]);
   ```

2. 更新元素

   ```java
   int[] array = new int[]{3,1,2,5,4,9,7,2};
   array[5] = 10;
   System.out.println(array[5]);
   ```

3. 插入元素

   - 尾部插入
   - 中间插入
   - 超范围插入（需要创建一个新数组）

4. 删除元素

   数组的删除操作和插入操作的过程相反，如果删除的元素位于数组中间，其后的元素都需要向前挪动一位。

##### 1.1.2 数组的优势和劣势

数组具有非常高效的随机访问能力，只要给出下标，就可以用常量时间找到对应的元素。比如：二分查找。

劣势体现在插入和删除方面，由于数组元素连续紧密地存储在内存中，插入和删除元素都会导致大量的元素被迫移动，影响效率。

总体来说，数组适合的是读操作多，写操作少的场景。

#### 1.2 链表

链表是一种在物理上非连续、非顺序的数据结构，由若干节点组成。

单项链表的每一个节点又包含两部分，一部分是存放数据的变量data，另一部分是指向下一个节点的指针next。

双向链表每个节点除了拥有data和next指针，还有指向前置节点的prev指针。

如果说数组在内存中存储方式是顺序存储，那么链表在内存中的存储方式是随机存储。

##### 1.2.1 链表的基本操作

查找的时间复杂度是`O(n)`

不考虑查找过程，插入和删除的时间复杂度是`O(1)`

1. 查找节点

   链表只能从头节点开始向后一个一个节点逐一查找。

2. 更新节点

   忽略查找的过程，和数组类似

3. 插入

   - 尾部插入

     把最后一个节点的next指针指向新插入的节点即可

   - 头部插入

     把新节点的next指针指向原先的头结点

     把新节点变为链表的头结点（指针）

   - 中间插入

     新节点的next指针，指向插入位置的节点

     插入位置的前置节点的next指针指向新节点

   只要内存空间允许，能够插入链表的元素时无穷无尽的，不需要考虑扩容的问题。

4. 删除元素

   - 尾部删除

     把倒数第二个节点的next指针指向空即可

   - 头部删除

     把链表的头节点设为原先头节点的next指针即可

   - 中间删除

     把要删除节点的前置节点的next指针，指向要删除的元素的下一个节点即可

#### 1.3 数组VS链表

|      | 查找 | 更新 | 插入 | 删除 |
| ---- | ---- | ---- | ---- | ---- |
| 数组 | O(1) | O(1) | O(n) | O(n) |
| 链表 | O(n) | O(1) | O(1) | O(1) |

数组的优势在于能够快速的定位元素，对于读操作多、写操作少的场景，用数组更合适。

链表的优势在于能够灵活的进行插入和删除操作，如果需要在尾部频繁插入，删除元素，用链表更合适一些。、

### 2. 栈和队列

物理结构、逻辑结构：

{% asset_img slug 逻辑结构和物理结构.png %}

#### 2.1 栈

栈是一种线性数据结构，栈内元素只能先入后出。最早进入的元素存放的位置叫做栈底，最后进入的元素存放的位置叫做栈顶。

##### 2.1.1 栈的基本操作

入栈和出栈的时间复杂度都是`O(1)`

1. 入栈（push）

   只允许从栈顶一侧放入数据，新元素会成为栈顶

2. 出栈（pop）

   只有栈顶元素才允许出栈，出栈元素的前一个元素将会成为新的栈顶

#### 2.2 队列

对列是一种线性数据结构，队列中的元素只能先入先出，队列的出口端叫做队头，队列的入口端叫做队尾

##### 2.2.1 队列的基本操作

入队和出队的时间复杂度为`O(1)`

1. 入队（enqueue）
2. 出队（dequeue）

用数组实现的队列可以采用循环队列的方式来维持队列容量的恒定。

假设一个队列经过反复的入队和出队操作，还剩下两个元素，在物理上 分布于数组的末尾位置。这是又有一个新元素要入队

{% asset_img slug 队列01.png %}

在数组不做扩容的前提下，我们可以利用已出队元素留下的空间，让队尾指针重新指回数组的首位。

{% asset_img slug 队列02.png %}

这样一来整个队列的元素就"循环"起来了。在物理存储上，队尾的位置也可以在对头之前。当再有元素入队时，将其放在数组首位，队尾指针继续后移即可。

{% asset_img slug 队列03.png %}

一直到`(队尾下标 + 1) % 数组长度 = 对头下标 ` 时，代表队列真的已经满了，需要注意的是，队尾指针指向的位置永远空出一位，所以队列最大容量比数组长度小1。

#### 2.3 栈和队列的应用

##### 2.3.1 栈的应用

栈的输出顺序和输入顺序相反，所以栈通常用于对历史的回溯

例如实现递归的逻辑，就可以用栈来代替，因为栈可以回溯方法的调用链

栈还有一个著名的应用场景是面包屑导航。

##### 2.3.2 队列的应用

队列的输出顺序和输入顺序相同，所以队列通常用于对历史的回放。

在多线程中，争夺公平锁的等待队列

网络爬虫实现网站抓取，把待抓取的url存入队列

##### 2.3.3 双端队列

双端队列这种数据结构，综合了栈和队列的优点，对双端队列来说，从对头的一端可以入队或出队，从队尾的一端也可以入队或出队

##### 2.3.4 优先队列

遵循谁的优先级最高，谁先出队。

### 3. 散列表

散列表也叫做哈希表，这种数据结构提供了key和value的映射关系，只要给出一个key，就可以高效的查找它所匹配的value，时间复杂度接近于`O(1)`。

#### 3.1 哈希函数

通过某种方式，把key和数组下标进行转换。

#### 3.2 散列表的读写操作

1. 写操作

   就是在散列表中插入新的键值对。

   如调用`hashMap.put("002931", "王五")`，意思就是插入一组key为002931、value为王五的键值对。

   具体步骤：

   - 通过哈希函数，把key转化成数组下标5

   - 如果数组下标5对应的位置没有元素，就把这个Entry填充到数组下标5的位置。

     {% asset_img slug hash散列表01.png %}

   但是，由于数组的长度是有限的，当插入的Entry越来越多时，不同的key通过哈希函数获得的下标有可能是相同的。例如`002936`这个key对应的数组下标是2；

   {% asset_img slug hash散列表02.png %}

   `002947`这个key对应的数组下标也是2。这就产生了哈希**冲突**。

   解决哈希冲突的方法有两种，一种开放寻址法，一种是链表法。

   - 开放寻址法

     当一个key通过哈希函数获得对应的数组下标已被占用时，可以去寻找下一个空挡位置。

     以上面的情况为例，Entry6通过哈希函数得到下标2，该下标在数组中已经有了其他元素，那么就向后移动1位，看看数组下标3的位置是否有空

     {% asset_img slug 开放寻址法01.png %}

     很不巧，下标3也已经被占用，那么久再向后移动一位，看看数组下标4的位置是否有空。

     {% asset_img slug 开放寻址法02.png %}

     幸运的是，数组下标4的位置还没有被占用，因此把Entry6存入下标4的位置

     {% asset_img slug 开放寻址法03.png %}

     这就是开放寻址法的基本思路。

   - 链表法

     这种方法被应用在java的集合类HashMap中

     HashMap数组的每一个元素不仅是一个Entry对象，还是一个链表的头节点。每一个Entry对象通过next指针指向它的下一个Entry节点。当新来的Entry映射到与之冲突的数组位置时，只需要插入到对应的链表中即可。

     {% asset_img slug 链表法.png %}

2. 读操作

   读操作就是通过给定的key，在散列表中查找对应的value。

   例如：调用`hashMap.get("002936")`，意思是查找key为002936的Entry在散列表中所对应的值。以链表法为例

   - 通过哈希函数，把key转化成数组的下标2

   - 找到数组下标2所对应的元素，如果这个元素的key是002936那么久找到了；如果不是，由于数组的每个元素都与一个链表对应，我们可以顺着链表慢慢往下找。

     {% asset_img slug 散列表读操作.png %}

     上图中，首先查到的节点Entry6的key是002974，和待查找的key002936不符，接着定位到列表下一个节点Entry1，发现Entry1的key002936正是我们要寻找的，所以返回Entry1的value即可。

3. 扩容（resize）

   当经过多次元素插入，散列表达到一定饱和时，key映射位置发生冲突的概率会逐渐提高。这样一来，大量的元素拥挤在相同的数组下标位置，形成很长的链表，对后续插入操作和查询操作的性能都有很大影响。

   {% asset_img slug 散列表扩容.png %}

   这时，散列表就需要扩展它的长度，也就是进行扩容。

   对于JDK中的散列表实现类HashMap来说，影响其扩容的因素有两个。

   - Capacity，即HashMap的当前长度
   - LoadFactor，即HashMap的负载因子，默认值为0.75f

   衡量HashMap需要进行扩容的条件如下。

   `HashMap.Size >= Capacity × LoadFactor`

   扩容的步骤：

   - 扩容，创建一个新的Entry空数组，长度是原数组的2倍。
   - 重新Hash，遍历原Entry数组，把所有的Entry重新hash到新数组中。为什么要重新Hash呢？因为长度扩大以后，Hash的规则也随之改变。

   经过扩容，原本拥挤的散列表重新变得稀疏，原有的Entry也重新得到了尽可能均匀的分配。

   {% asset_img slug 扩容前后HashMap.png %}

### 注

python中的list在内存中是连续的，之所以不需要考虑扩容的问题，是因为list是动态扩容。