---
title: mysql游标
date: 2019-12-25
tags:
- 数据库
- 后端
- mysql
categories:
- 数据库
- mysql
---

### 使用游标

- 在能够使用游标前，必须先声明（定义）它，这个过程实际上没有检索数据，只是定义要使用的`SELECT`语句
- 一旦声明后，必须打开游标以供使用。这个过程用前面定义的`SELECT`语句把数据实际检索出来
- 对于填有数据的游标，根据需要取出（索引）各行
- 在结束游标使用时，必须关闭游标

<!--more-->

#### 创建游标

游标用`DECLARE`语句创建，`DECLARE`命名游标，并定义相应的`SELECT`语句，根据需要带WHERE和其他子句。

下面的语句定义了名为`ordernumbers`的游标，使用了可以检索所有订单的`SELECT`语句。

```SQL
CREATE PROCEDURE processorders()
BEGIN
	DECLARE ordernumbers CURSOR
	FOR
	SELECT order_num FROM orders;
END;
```

#### 打开和关闭游标

打开游标

```sql
OPEN ordernumbers;
```

关闭游标

```sql
CLOSE ordernumbers;
```

隐含关闭

如果你不明确关闭游标，MySQL将会在到达END语句时自动关闭它。

```SQL
CREATE PROCEDURE processorders()
BEGIN
	-- Declare the cursor
	DECLARE ordernumbers CURSOR
	FOR
	SELECT order_num FROM orders;
	
	-- Open the cursor
	OPEN ordernumbers;
	
	-- Close the cursor
	CLOSE ordernumbers;
END;
```

#### 使用游标数据

在一个游标被打开后，可以使用FETCH语句分别访问它的每一行。FETCH指定检索什么数据（所需的列），检索出来的数据存储在什么地方。它还向前移动游标中的内部行指针，使用下一条FETCH语句检索下一行（不重复读取同一行）。

```SQL
CREATE PROCEDURE processorders()
BEGIN
	-- Declare local variables
	DECLARE o INT;
	
	-- Declare the cursor
	DECLARE ordernumbers CURSOR
	FOR
	SELECT order_num FROM orders;
	
	-- Open the cursor
	OPEN ordernumbers;
	
	-- Get order number
	FETCH ordernumbers INTO o; -- 检索当前行的order_num列（将自动从第一行开始）到一个名为o的局部声明的变量中。
	
	-- Close the cursor
	CLOSE ordernumbers;
END;
```

下面一个例子，循环检索数据，从第一行到最后一行

```SQL
CREATE PROCEDURE processorders()
BEGIN
	-- Declare local variables
	DECLARE done BOOLEAN DEFAULT 0;
	DECLARE o INT;
	
	-- Declare the cursor
	DECLARE ordernumbers CURSOR
	FOR
	SELECT order_num FROM orders;
	-- Declare continue handler
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done=1;
	-- Open the cursor
	OPEN ordernumbers;
	
	-- Loop through all rows
	REPEAT
		-- Get order number
		FETCH ordernumbers INTO o;
	-- End of loop
	UNTIL done END REPEAT;
	
	-- Close the cursor
	CLOSE ordernumbers;
END;
```

这个例子中的FETCH是在REPEAT内，因此它反复执行直到done为真（由UNTIL done END REPEAT;规定）。为使它起作用，用一个DEFAULT 0（假，不结束）定义变量done。

通过这个语句将done设为1

```
DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done=1;
```

指当`SQLSTATE '02000'`出现时，SET done=1。这里`SQLSTATE '02000'`是一个未找到条件，当REPEAT由于没有更多行供循环而不能继续时，出现这个条件。

如果调用这个存储过程，它将定义几个变量和一个CONTINUE HANDLER，定义并打开一个游标，重复读取所有行，然后关闭游标。

**DECLARE语句的次序**，DECLARE语句发布存在特定的次序。用DECLARE语句定义的局部变量必须在定义任意游标或句柄之前定义。

```SQL
CREATE PROCEDURE processorders()
BEGIN
	-- Declare local variables
	DECLARE done BOOLEAN DEFAULT 0;
	DECLARE o INT;
	DECLARE t DECIMAL(8, 2);
	
	-- Declare the cursor
	DECLARE ordernumbers CURSOR
	FOR
	SELECT order_num FROM orders;
	-- Declare continue handler
	DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done=1;
	
	-- Create a table to store the results
	CREATE TABLE IF NOT EXISTS ordertotals(order_num INT, total DECIMAL(8, 2));
	
	-- Open the cursor
	OPEN ordernumbers;
	-- Loop through all rows
	REPEAT
		-- Get order number
		FETCH ordernumbers INTO O;
		
		-- Get the total for this order
		CALL ordertotal(o, 1, t)
		
		-- Insert order and total into ordertotals
		INSERT INTO ordertotals(order_num, total) VALUES(o, t);
	-- End of loop
	UNTIL done END REPEAT;
	
	-- Close the cursor
	CLOSE ordernumbers;
END;
```

这个例子中，增加了另一个名为t的变量，存储每个订单的合计。此存储过程还在运行中创建了一个新表（如果它不存在的话），名为`ordertotals`。这个表将保存存储过程生成的结果。FETCH像之前一样，取每个`order_num`，然后用CALL 执行另一个存储过程（在存储过程中创建的）来计算每个订单的带税合计，结果存储到t，最后用INSERT保存每个订单的订单号和合计。

```sql
SELECT * FROM ordertotals;
```

{% asset_img slug 1577257001907.png %}

