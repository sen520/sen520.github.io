---
title: mysql触发器
date: 2019-12-25
tags:
- 数据库
- 后端
- mysql
categories:
- 数据库
- mysql
---

MySQL语句在需要时被执行，存储过程也是。但如果想要某条语句在事件发生时自动执行，怎么办呢？

- 每当增加一个顾客到某个数据库表时，都检查其电话号码的格式是否正确，州的缩写是否为大写
- 每当订购一个产品时，都从库存数量中减去订购的数量
- 无论何时删除一行，都在某个存档表中保留一个副本

这些都需要在某个表发生更改时自动处理，就是触发器。

触发器是MySQL响应一下任意语句而自动执行的一条MySQL语句

- DELETE
- INSERT
- UPDATE

### 创建触发器

需要给出4条信息

- 唯一的触发器名
- 触发器关联表
- 触发器应该响应的活动(DELETE, INSERT, UPDATE)

- 触发器何时执行

```sql
CREATE TRIGGER newproduct AFTER INSERT ON products FOR EACH ROW SELECT 'Product added';
```

CREATE TRIGGER用来创建名为newproduct的新触发器。触发器可在一个操作发生前或之后执行。这里给出了AFTER INSERT，所以此触发器将在INSERT语句成功执行后执行。这个触发器还指定FOR EACH ROW ，因此代码对每个插入行执行。这个例子中，文本Product added 将对每个插入的行显示一次。

**只有表才支持触发器，视图不支持**

触发器按每个表每个事件每次地定义，每个表每个事件每次只允许一个触发器。因此每个表最多支持6个触发器（每条INSERT、UPDATE、DELETE的之前和之后）。单一触发器不能与多个事件或多个表关联。所以，如果需要一个对INSERT和UPDATE操作执行的触发器，则应该定义两个触发器。

### 删除触发器

```sql
DROP TRIGGER newproduct;
```

### 使用触发器

#### INSERT触发器

INSERT触发器在INSERT语句执行之前或之后执行。

- 在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行
- 在BEFORE INSERT触发器中，NEW中的值也可以被更新（允许更改被插入的值）
- 对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自动生成值

例：

- ```sql
  CREATE TRIGGER neworder AFTER INSERT ON orders
  FOR EACH ROW SELECT NEW.order_num;
  ```

  创建了一个名为neworder的触发器，按照AFTER INSERT ON orders执行。在插入一个新订单到orders表时，MySQL生成一个新订单号并保存到order_num中。触发器从NEW.order_num取得这个值并返回它。此触发器必须按照AFTER INSERT执行，因为在BEFORE INSERT语句执行之前，新的order_num还没有生成。对于orders的每次插入使用这个触发器将总是返回新的订单号。

  ```sql
  INSERT INTO orders(order_date, cust_id) VALUES(Now(), 10001);
  ```

  orders包含3个列，order_date和cust_id必须给出，order_num由MySQL自动生成，而现在order_num还自动被返回

    {% asset_img slug 1577258795707.png %}

#### DELETE触发器

- 在DELETE触发器代码内，可以引用一个名为OLD的虚拟表，访问被删除的行
- OLD中的值全都是只读的，不能更新

```sql
CREATE TRIGGER deleteorder BEFORE DELETE ON orders
FOR EACH ROW
BEGIN
	INSERT INTO archive_orders(order_num, order_date, cust_id) VALUES(OLD.order_num, OLD.order_date, OLD.cust_id);
END;
```

在任意订单被删除前，执行此触发器，将OLD中的值（要被删除的订单）保存到一个名为archive_orders的存档表中

#### UPDATE触发器

- 在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问以前的（UPDATE语句前）的值，引用一个名为NEW的虚拟表访问新更新的值
- 在BEFORE UPDATE触发器中，NEW中的值可能也被更新（允许更改将要用于UPDATE语句中的值）
- OLD中的值全都是只读的，不能更新

下面的例子保证州名缩写总是大写：

```sql
CREATE TRIGGER updatevendor BEFORE UPDATE ON vendors
FOR EACH ROW SET NEW.vend_state = Upper(NEW.vend_state);
```

